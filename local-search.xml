<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>两数之和 - 从双重循环到哈希字典的优化</title>
    <link href="/2025/09/23/2025.9.23/"/>
    <url>/2025/09/23/2025.9.23/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分，初始shell</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>两数之和 - 从双重循环到哈希字典的优化</title>
    <link href="/2025/09/21/2025.9.21/"/>
    <url>/2025/09/21/2025.9.21/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值 <code>target</code> 的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：双重循环（暴力枚举）"><a href="#方法一：双重循环（暴力枚举）" class="headerlink" title="方法一：双重循环（暴力枚举）"></a>方法一：双重循环（暴力枚举）</h3><p><strong>思路</strong>：遍历每个元素 <code>x</code>，并查找是否存在一个值与 <code>target - x</code> 相等的目标元素。</p><p><strong>时间复杂度</strong>：O(n²) - 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素。<br><strong>空间复杂度</strong>：O(1) - 只使用了常数级别的额外空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br></code></pre></td></tr></table></figure><h3 id="方法二：哈希表-字典（优化解法）"><a href="#方法二：哈希表-字典（优化解法）" class="headerlink" title="方法二：哈希表&#x2F;字典（优化解法）"></a>方法二：哈希表&#x2F;字典（优化解法）</h3><p><strong>思路</strong>：使用字典（哈希表）来存储每个元素的值及其索引。在遍历数组时，我们检查当前元素所需的补数（target - num）是否已经存在于字典中。如果存在，立即返回结果；如果不存在，则将当前元素的值和索引存入字典，继续遍历。</p><p><strong>时间复杂度</strong>：O(n) - 我们只遍历了包含有 n 个元素的列表一次。在字典中查找补数的时间复杂度为 O(1)。</p><p><strong>空间复杂度</strong>：O(n) - 所需的额外空间取决于字典中存储的元素数量，最多需要存储 n 个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        hashmap = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            complement = target - num<br>            <span class="hljs-comment"># 检查补数是否已在哈希表中</span><br>            <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> hashmap:<br>                <span class="hljs-keyword">return</span> [hashmap[complement], i]<br>            <span class="hljs-comment"># 将当前数字存入哈希表（注意：必须在检查之后存入！）num当索引，i当值</span><br>            hashmap[num] = i<br></code></pre></td></tr></table></figure><p><strong>hashmap中根据 Key 找 Value</strong>：my_dict[‘name’]&#x2F;my_dict.get(‘name’)<br><strong>hashmap中根据 Value 找 Key</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历查找（找到第一个匹配的）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_key_by_value</span>(<span class="hljs-params">dictionary, target_value</span>):<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> dictionary.items():<br>        <span class="hljs-keyword">if</span> value == target_value:<br>            <span class="hljs-keyword">return</span> key<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 如果没找到</span><br><br><span class="hljs-comment">#列表推导式（找到所有匹配的key）</span><br>keys = [key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items() <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#字典推导式（创建一个新字典，将value变为key，将key变为value）</span><br><span class="hljs-comment">#创建反向字典（注意：value必须是唯一的）</span><br>reverse_dict = &#123;value: key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items()&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
