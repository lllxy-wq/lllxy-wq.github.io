<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shell脚本</title>
    <link href="/2025/11/14/shell/"/>
    <url>/2025/11/14/shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-脚本基础"><a href="#Shell-脚本基础" class="headerlink" title="Shell 脚本基础"></a>Shell 脚本基础</h1><h2 id="脚本命名与头部说明"><a href="#脚本命名与头部说明" class="headerlink" title="脚本命名与头部说明"></a>脚本命名与头部说明</h2><ul><li>命名建议有意义，使用 <code>.sh</code> 结尾</li><li>以 <code>#!</code> 开头定义脚本运行环境，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>````<br><br>* 不是注释，脚本运行时会自动执行<br>* 建议添加作者信息与脚本描述：<br><br></code></pre></td></tr></table></figure><h1 id="Author：作者"><a href="#Author：作者" class="headerlink" title="Author：作者"></a>Author：作者</h1><h1 id="Create-Time：创建时间"><a href="#Create-Time：创建时间" class="headerlink" title="Create Time：创建时间"></a>Create Time：创建时间</h1><h1 id="Script-Description：描述"><a href="#Script-Description：描述" class="headerlink" title="Script Description：描述"></a>Script Description：描述</h1><h1 id="Release：版本信息"><a href="#Release：版本信息" class="headerlink" title="Release：版本信息"></a>Release：版本信息</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>脚本组成：<br><br><span class="hljs-bullet">1.</span> 解释环境 (<span class="hljs-code">`#!`</span>)<br><span class="hljs-bullet">2.</span> 注释说明<br><span class="hljs-bullet">3.</span> 执行代码<br><br><span class="hljs-section">### 脚本运行方式</span><br><br><span class="hljs-bullet">1.</span> 赋予执行权限后运行：<br><br><span class="hljs-code">```bash</span><br><span class="hljs-code">chmod +x script.sh</span><br><span class="hljs-code">./script.sh</span><br></code></pre></td></tr></table></figure><ol start="2"><li>用解释器直接运行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash script.sh<br>sh script.sh<br></code></pre></td></tr></table></figure><hr><h1 id="常用特殊符号"><a href="#常用特殊符号" class="headerlink" title="常用特殊符号"></a>常用特殊符号</h1><table><thead><tr><th>符号</th><th>作用</th><th></th></tr></thead><tbody><tr><td><code>~</code></td><td>家目录</td><td></td></tr><tr><td><code>$</code></td><td>变量</td><td></td></tr><tr><td><code>!</code></td><td>执行上一条命令</td><td></td></tr><tr><td><code>+-*/%</code></td><td>运算符</td><td></td></tr><tr><td><code>&amp;</code></td><td>后台运行</td><td></td></tr><tr><td><code>*</code></td><td>通配符，匹配所有</td><td></td></tr><tr><td><code>?</code></td><td>通配符，匹配单个字符</td><td></td></tr><tr><td><code>;</code></td><td>一行执行多条命令</td><td></td></tr><tr><td>&#96;</td><td>&#96;</td><td>管道符</td></tr><tr><td><code>\</code></td><td>转义符</td><td></td></tr><tr><td><code>`command`</code></td><td>反引号执行命令</td><td></td></tr><tr><td><code>&#39; &#39;</code></td><td>单引号，不能解析变量</td><td></td></tr><tr><td><code>&quot; &quot;</code></td><td>双引号，可解析变量</td><td></td></tr></tbody></table><hr><h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><h3 id="expr（整数运算）"><a href="#expr（整数运算）" class="headerlink" title="expr（整数运算）"></a>expr（整数运算）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span> 1 + 2<br><span class="hljs-built_in">expr</span> 1 \* 2<br><span class="hljs-built_in">expr</span> 1 / 2<br></code></pre></td></tr></table></figure><h3 id="bc（支持小数）"><a href="#bc（支持小数）" class="headerlink" title="bc（支持小数）"></a>bc（支持小数）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; 1/2&quot;</span> | bc<br></code></pre></td></tr></table></figure><h3 id="shell-内建运算"><a href="#shell-内建运算" class="headerlink" title="shell 内建运算"></a>shell 内建运算</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $((<span class="hljs-number">1</span> + <span class="hljs-number">2</span>))<br><span class="hljs-built_in">echo</span> $((<span class="hljs-number">1</span> * <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>退出脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span> num  <span class="hljs-comment"># num 为 0-255，默认为 0</span><br></code></pre></td></tr></table></figure><hr><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>echo</code></td><td>普通输出</td></tr><tr><td><code>echo -e</code></td><td>启用转义字符</td></tr><tr><td><code>echo -n</code></td><td>不换行输出</td></tr></tbody></table><p>常用转义字符：</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\b</code></td><td>退格</td></tr><tr><td><code>\a</code></td><td>响铃</td></tr></tbody></table><h3 id="输出颜色"><a href="#输出颜色" class="headerlink" title="输出颜色"></a>输出颜色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[背景色;字体色m 字符串 \033[0m&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>字体色：30-37</p></li><li><p>背景色：40-47</p></li><li><p>属性：</p><ul><li><code>\033[0m</code> 关闭属性</li><li><code>\033[1m</code> 高亮</li><li><code>\033[4m</code> 下划线</li><li><code>\033[5m</code> 闪烁</li><li><code>\033[7m</code> 反显</li><li><code>\033[8m</code> 消隐</li></ul></li></ul><hr><h1 id="shell-输入"><a href="#shell-输入" class="headerlink" title="shell 输入"></a>shell 输入</h1><p><code>read</code> 命令默认接受键盘输入，回车结束。</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td><code>-p</code></td><td>打印提示信息</td></tr><tr><td><code>-s</code></td><td>不显示输入</td></tr><tr><td><code>-t</code></td><td>输入超时</td></tr><tr><td><code>-n</code></td><td>限制输入字符数</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>clear<br><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Login: &quot;</span> acc<br><span class="hljs-built_in">echo</span> -n -e <span class="hljs-string">&quot;Password: &quot;</span><br><span class="hljs-built_in">read</span> pw<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;account: <span class="hljs-variable">$acc</span>   Password: <span class="hljs-variable">$pw</span>&quot;</span><br></code></pre></td></tr></table></figure><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>本地变量：用户私有，保存在 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code></li><li>全局变量：所有用户可用，保存在 <code>/etc/profile</code> 或 <code>/etc/bashrc</code></li><li>用户自定义变量：脚本中定义</li></ul><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">变量名=值<br></code></pre></td></tr></table></figure><p>命名规则：</p><ul><li>只能包含字母、数字、下划线</li><li>首字母不能为数字</li><li>不能使用特殊字符或 Bash 关键字</li><li>字符串建议加引号</li></ul><h3 id="使用与删除"><a href="#使用与删除" class="headerlink" title="使用与删除"></a>使用与删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> $变量名<br><span class="hljs-built_in">unset</span> 变量名<br></code></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> 变量名=值<br></code></pre></td></tr></table></figure><h3 id="永久变量"><a href="#永久变量" class="headerlink" title="永久变量"></a>永久变量</h3><p>写入 <code>/etc/profile</code> 或 <code>~/.bashrc</code></p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">array=(a b c)<br></code></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[0]&#125;</span>    <span class="hljs-comment"># 第一个元素</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[@]&#125;</span>    <span class="hljs-comment"># 所有元素</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#array[@]&#125;</span>   <span class="hljs-comment"># 元素个数</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;!array[@]&#125;</span>   <span class="hljs-comment"># 元素索引</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[@]:1&#125;</span>  <span class="hljs-comment"># 从索引1开始</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[@]:1:2&#125;</span> <span class="hljs-comment"># 从索引1开始取两个</span><br></code></pre></td></tr></table></figure><h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> -A arr<br>arr[name]=Tom<br>arr[age]=20<br></code></pre></td></tr></table></figure><hr><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td></tr><tr><td>-ne</td><td>不等于</td></tr><tr><td>-gt</td><td>大于</td></tr><tr><td>-lt</td><td>小于</td></tr><tr><td>-ge</td><td>大于等于</td></tr><tr><td>-le</td><td>小于等于</td></tr></tbody></table><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>-z</td><td>空</td></tr><tr><td>-n</td><td>非空</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr></tbody></table><h2 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h2><table><thead><tr><th>条件</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>是否目录</td></tr><tr><td>-f</td><td>是否普通文件</td></tr><tr><td>-e</td><td>是否存在</td></tr><tr><td>-s</td><td>是否存在且非空</td></tr><tr><td>-r</td><td>是否可读</td></tr><tr><td>-w</td><td>是否可写</td></tr><tr><td>-x</td><td>是否可执行</td></tr><tr><td>-O</td><td>是否属于当前用户</td></tr><tr><td>-G</td><td>是否属于当前用户组</td></tr><tr><td>file1 -nt file2</td><td>file1 是否更新</td></tr><tr><td>file1 -ot file2</td><td>file1 是否更旧</td></tr></tbody></table><hr><h1 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h1><h3 id="单-if"><a href="#单-if" class="headerlink" title="单 if"></a>单 if</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ 条件 ]; <span class="hljs-keyword">then</span><br>    命令<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ 条件 ]; <span class="hljs-keyword">then</span><br>    命令1<br><span class="hljs-keyword">else</span><br>    命令2<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if-elif-else"></a>if-elif-else</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ 条件1 ]; <span class="hljs-keyword">then</span><br>    ...<br><span class="hljs-keyword">elif</span> [ 条件2 ]; <span class="hljs-keyword">then</span><br>    ...<br><span class="hljs-keyword">else</span><br>    ...<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><hr><h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法 1"></a>语法 1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> a b c; <span class="hljs-keyword">do</span><br>    命令<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法 2"></a>语法 2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> ((i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)); <span class="hljs-keyword">do</span><br>    命令<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><ul><li><code>sleep N</code></li><li><code>continue</code></li><li><code>break</code></li></ul><hr><h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> [ 条件 ]; <span class="hljs-keyword">do</span><br>    命令<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><code>until</code> 与 while 相反，条件为假时循环</p><hr><h1 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> 值 <span class="hljs-keyword">in</span><br>    条件1)<br>        命令<br>    ;;<br>    条件2)<br>        命令<br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><hr><h1 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h1><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$*</td><td>所有参数（按 IFS 分隔）</td></tr><tr><td>$@</td><td>所有参数（独立处理）</td></tr><tr><td>$#</td><td>参数个数</td></tr><tr><td>$-</td><td>最近执行的命令参数</td></tr><tr><td>$$</td><td>当前进程号</td></tr><tr><td>$?</td><td>上一命令返回值</td></tr><tr><td>$!</td><td>最近后台进程号</td></tr><tr><td>$_</td><td>上一次命令的最后参数</td></tr><tr><td>$N</td><td>第 N 个参数</td></tr></tbody></table><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="写法-1"><a href="#写法-1" class="headerlink" title="写法 1"></a>写法 1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<br>    命令<br>    <span class="hljs-built_in">return</span> 值<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写法-2"><a href="#写法-2" class="headerlink" title="写法 2"></a>写法 2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">func</span></span>() &#123;<br>    命令<br>    <span class="hljs-built_in">return</span> 值<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux自动化运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本三剑客</title>
    <link href="/2025/11/12/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <url>/2025/11/12/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>Linux 中的通配符是一种特殊的符号,用于匹配文件名或目录名。这些通配符可以帮助用户更快地输入命令和文件路径。或者可以理解为用户文件名和路径的匹配。由shell进行解析，一般情况下与某些命令配合使用，如：find，cp，mv，ls，rm等。</p><h2 id="Shell中常见的通配符如下："><a href="#Shell中常见的通配符如下：" class="headerlink" title="Shell中常见的通配符如下："></a>Shell中常见的通配符如下：</h2><p>*: 匹配0或多个字符<br>?: 匹配任意一个字符<br>[….]: 匹配方括号中任意单个字符<br>[!….]: 匹配除了方括号中指定字符之外的字符<br>范围 [a-z]: 匹配指定范围内的任意一个字符<br>大括号 {}: 用于匹配由逗号分隔的单个字符串</p><h2 id="Shell元字符"><a href="#Shell元字符" class="headerlink" title="Shell元字符"></a>Shell元字符</h2><p>在 Shell 脚本中,除了通配符,还有一些特殊的元字符需要了解。这些元字符有特殊的含义,在编写 Shell 脚本时需要特别注意。以下是 Shell 中常见的一些元字符及其用法</p><p>IFS：<tab>&#x2F;<space>&#x2F;<enter><br>&#x3D;：设定变量<br>$：取变量值</p><blockquote><p>&#x2F;&lt; ：重定向<br>|：管道<br>&amp;：后台执行命令<br>()：在子shell中执行命令&#x2F;运算或命令替换<br>{}：用于扩展变量、生成序列等。<br>例如 echo {A..Z} 会输出 A 到 Z 的大写字母序列。<br>;：命令结束后，忽略其返回值，继续执行下一个命令<br>&amp;&amp;：命令结束后，若为true，继续执行下一个命令<br>||：命令结束后，若为false，继续执行下一个命令<br>!：非<br>#：注释<br>\：转义符</p></blockquote><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><ol><li>字符匹配</li></ol><ul><li><code>.</code>：匹配任意单个字符</li><li><code>[]</code>：匹配指定范围内任意单个字符 <code>[a-z]</code> <code>[0-9]</code></li><li><code>[^]</code>：匹配指定范围外任意单个字符 <code>[^a-z]</code> <code>[^0-9]</code></li><li><code>[:alnum:]</code>：字母与数字字符</li><li><code>[:alpha:]</code>：字母</li><li><code>[:ascii:]</code>：ASCII 字符</li><li><code>[:blank:]</code>：空格或制表符</li><li><code>[:cntrl:]</code>：ASCII 控制字符</li><li><code>[:digit:]</code>：数字</li><li><code>[:graph:]</code>：非控制、非空格字符</li><li><code>[:lower:]</code>：小写字母</li><li><code>[:print:]</code>：可打印字符</li><li><code>[:punct:]</code>：标点符号字符</li><li><code>[:space:]</code>：空白字符，包括垂直制表符</li><li><code>[:upper:]</code>：大写字母</li><li><code>[:xdigit:]</code>：十六进制数字</li></ul><ol start="2"><li>匹配次数</li></ol><ul><li><code>*</code>：匹配前面的字符任意次数</li><li><code>.*</code>：匹配任意长度的字符</li><li><code>\?</code>：匹配其前面字符 0 或 1 次，即前面的可有可无 <code>&#39;a\?b&#39;</code></li><li><code>\+</code>：匹配其前面的字符至少 1 次 <code>&#39;a\+b&#39;</code></li><li><code>\&#123;m\&#125;</code>：匹配前面的字符 m 次</li><li><code>\&#123;m,n\&#125;</code>：匹配前面的字符至少 m 次，至多 n 次</li><li><code>\&#123;0,n\&#125;</code>：匹配前面的字符至多 n 次</li><li><code>\&#123;m,\&#125;</code>：匹配前面的字符至少 m 次</li></ul><ol start="3"><li>位置锚定</li></ol><ul><li><code>^</code>：行首锚定，用于模式的最左侧</li><li><code>$</code>：行末锚定，用于模式的最右侧</li><li><code>^PATTERN$</code>：用于模式匹配整行</li><li><code>^$</code>：空行</li><li><code>\&lt;</code> 或 <code>\b</code>：词首锚定，用于单词模式的左侧</li><li><code>\&gt;</code> 或 <code>\b</code>：词尾锚定，用于单词模式的右侧</li><li><code>\&lt;PATTERN\&gt;</code>：匹配整个单词 <code>&#39;\&lt;hello\&gt;&#39;</code></li></ul><ol start="4"><li>分组</li></ol><ul><li><code>()</code>: 用于分组,可以对一组字符应用量词等操作</li><li>分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中</li><li><code>\1</code>、<code>\2</code> 等: 用于引用前面匹配的分组内容</li><li><code>\1</code>:从左侧起，第一个左括号以及与之匹配右括号之间的模式所匹配到的字符；</li></ul><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>主要用于过滤文本内容</p><p>-E :–extended–regexp模式是扩展正则表达式（ERE）<br>-i :–ignore–case忽略大小写<br>-n: –line–number打印行号<br>-o:–only–matching只打印匹配的内容<br>-c:–count只打印每个文件匹配的行数<br>-B:–before–context&#x3D;NUM打印匹配的前几行<br>-A:–after–context&#x3D;NUM打印匹配的后几行<br>-C:–context&#x3D;NUM打印匹配的前后几行<br>–color[&#x3D;WHEN]匹配的字体颜色，别名已定义了<br>-v:–invert–match打印不匹配的行<br>-e多点操作eg：grep -e “^s” -e “s$”</p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>主要用于编辑文本内容</p><p>sed 是一个强大的文本处理工具,它可以用于对文本进行搜索、替换、删除、插入等操作。<br>sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><p>语法<br>sed的命令格式： sed [option] ‘sed command’ filename<br>sed的脚本格式：sed [option] ‐f ‘sed script’ filename</p><p>常用选项：<br>‐n ：只打印模式匹配的行<br>‐e ：直接在命令行模式上进行sed动作编辑，此为默认选项<br>‐f ：将sed的动作写在一个文件内，用–f filename 执行filename内的sed动作<br>‐r ：支持扩展表达式<br>‐i ：直接修改文件内容<br>查询文本的方式<br>使用行号和行号范围<br>x：行号<br>x,y：从x行到y行<br>x,y!：x行到y行之外<br>&#x2F;pattern：查询包含模式的行<br>&#x2F;pattern&#x2F;, &#x2F;pattern&#x2F;：查询包含两个模式的行<br>&#x2F;pattern&#x2F;,x：x行内查询包含模式的行<br>x,&#x2F;pattern&#x2F;：x行后查询匹配模式的行<br>动作说明<br>常用选项：<br>p：打印匹配的行(‐n)<br>&#x3D;：显示文件行号<br>a\：指定行号后添加新文本<br>i\：指定行号前添加新文本<br>d：删除定位行<br>c\：用新文本替换定位文本<br>w filename：写文本到一个文件<br>r filename：从另一个文件读文本<br>s&#x2F;&#x2F;&#x2F;：替换<br>替换标记：<br>g：行内全局替换<br>p：显示替换成功的行<br>w：将替换成功的结果保存至指定文件<br>q：第一个模式匹配后立即退出<br>{}：在定位行执行的命令组，用逗号分隔<br>g：将模式2粘贴到&#x2F;pattern n&#x2F;</p><p>sed ‘s&#x2F;要被取代的字串&#x2F;新的字串&#x2F;g’</p><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>主要用于分析文本内容</p><h2 id="BEGIN-和-END-模块"><a href="#BEGIN-和-END-模块" class="headerlink" title="BEGIN 和 END 模块"></a>BEGIN 和 END 模块</h2><p>在 awk 中，BEGIN 和 END 是两个特殊的模式块，它们分别在处理文件之前和处理文件之后执行。它们的作用如下：</p><ol><li>BEGIN 块<br>BEGIN 块中的代码在 awk 开始处理文件之前执行。它通常用于：<br>初始化变量。<br>设置字段分隔符。<br>执行一些预处理操作。</li><li>END 块<br>END 块中的代码在 awk 处理完文件之后执行。它通常用于：<br>输出总结信息。<br>执行一些后处理操作。<br>案例一：统计当前系统中存在的账户数量</li></ol><h2 id="awk运算符"><a href="#awk运算符" class="headerlink" title="awk运算符"></a>awk运算符</h2><p>赋值运算符<br>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; ^&#x3D; **&#x3D;赋值语句<br>正则运算符<br>~ !~匹配正则表达式和不匹配正则表达式<br>逻辑运算符<br>\\逻辑或<br>&amp;&amp;逻辑与<br>关系运算符<br>&lt; &lt;&#x3D; &gt; &gt;&#x3D; !&#x3D; &#x3D;&#x3D;关系运算符<br>算数运算符</p><ul><li><ul><li>   加,减</li></ul></li></ul><ul><li>&#x2F; &amp;乘,除与求余</li></ul><ul><li><ul><li>!一元加,减和逻辑非<br>^ ***求幂<br>++ –增加或减少，作为前缀或后缀<br>其他运算符<br>$字段引用<br>空格字符串链接符</li></ul></li></ul><p>?:三目运算符<br>ln数组中是否存在某键值</p><h2 id="常用awk内置变量"><a href="#常用awk内置变量" class="headerlink" title="常用awk内置变量"></a>常用awk内置变量</h2><p>$0当前记录<br>$1~$n当前记录的第n个字段<br>FS输入字段分割符 默认是空格<br>RS输入记录分割符 默认为换行符<br>NF当前记录中的字段个数，就是有多少列<br>NR已经读出的记录数，就是行号，从1开始<br>OFS输出字段分割符 默认也是空格<br>ORS输出的记录分割符 默认为换行符</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux自动化运维</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2025/11/04/Nginx/"/>
    <url>/2025/11/04/Nginx/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Apache</title>
    <link href="/2025/10/28/Apache/"/>
    <url>/2025/10/28/Apache/</url>
    
    <content type="html"><![CDATA[<h1 id="Apache介绍"><a href="#Apache介绍" class="headerlink" title="Apache介绍"></a>Apache介绍</h1><p>Apache HTTP Server简称为Apache，是Apache软件基金会的一个高性能、功能强大、见状可靠、又灵活的开放源代码的web服务软件，它可以运行在广泛的计算机平台上如Linux、Windows。因其平台型和很好的安全性而被广泛使用，是互联网最流行的web服务软件之一</p><ul><li><p>特点<br>功能强大、高度模块化、采用MPM多路处理模块、配置简单、速度快、应用广泛、性能稳定可靠、可做代理服务器或负载均衡来使用、双向认证、支持第三方模块</p></li><li><p>应用场合<br>– 使用Apache运行静态HTML网页、图片<br>– 使用Apache结合PHP、Linux、MySQL可以组成LAMP经典架构<br>– 使用Apache作代理、负载均衡等</p></li><li><p>MPM工作模式<br>– prefork：多进程I&#x2F;O模型，一个主进程，管理多个子进程，一个子进程处理一个请求。<br>– worker：复用的多进程I&#x2F;O模型，多进程多线程，一个主进程，管理多个子进程，一个子进程管理多个线程，每个线程处理一个请求。<br>– event：事件驱动模型，一个主进程，管理多个子进程，一个进程处理多个请求。</p></li></ul><h1 id="Apache基础"><a href="#Apache基础" class="headerlink" title="Apache基础"></a>Apache基础</h1><p>安装apache[root@localhost ~]# yum -y install httpd</p><h2 id="httpd命令"><a href="#httpd命令" class="headerlink" title="httpd命令"></a>httpd命令</h2><p>httpd为Apache HTTP服务器程序。直接执行程序可启动服务器的服务<br>httpd [-hlLStvVX][-c&lt;httpd指令&gt;][-C&lt;httpd指令&gt;][-d&lt;服务器根目录&gt;][-D&lt;设定文件参数&gt;][-f&lt;设定文件&gt;]</p><ul><li>选项<br>– -c：在读取配置文件前，先执行选项中的指令。<br>– -C：在读取配置文件后，再执行选项中的指令。<br>– -d&lt;服务器根目录&gt;：指定服务器的根目录。<br>– -D&lt;设定文件参数&gt;：指定要传入配置文件的参数。<br>– -f&lt;设定文件&gt;：指定配置文件。<br>– -h：显示帮助。<br>– -l：显示服务器编译时所包含的模块。<br>– -L：显示httpd指令的说明。<br>– -S：显示配置文件中的设定。<br>– -t：测试配置文件的语法是否正确。<br>– -v：显示版本信息。<br>– -V：显示版本信息以及建立环境。<br>– -X：以单一程序的方式来启动服务器。</li></ul><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</td><td>Apache主配置文件</td></tr><tr><td>&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;</td><td>存放虚拟主机配置文件</td></tr><tr><td>&#x2F;etc&#x2F;httpd&#x2F;conf.modules.d&#x2F;</td><td>存放模块配置文件</td></tr><tr><td>&#x2F;etc&#x2F;httpd&#x2F;modules&#x2F;</td><td>存放模块文件</td></tr><tr><td>&#x2F;etc&#x2F;log&#x2F;httpd&#x2F;</td><td>存放日志文件</td></tr><tr><td>&#x2F;var&#x2F;www&#x2F;html&#x2F;</td><td>存放默认的网页文件</td></tr></tbody></table><h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1><p>httpd有两种日志类型：访问日志、错误日志<br>日志等级：debug, info, notice, warn,error, crit, alert,emerg</p><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>日志格式可以自定义，查看主配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# vim /etc/httpd/conf/httpd.conf<br>&lt;IfModule log_config_module&gt;<br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># The following directives define some format nicknames for use with</span><br>    <span class="hljs-comment"># a CustomLog directive (see below).</span><br>    <span class="hljs-comment">#</span><br>    LogFormat <span class="hljs-string">&quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot;</span> combined<br>    LogFormat <span class="hljs-string">&quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b&quot;</span> common<br><br>    &lt;IfModule logio_module&gt;<br>      <span class="hljs-comment"># You need to enable mod_logio.c to use %I and %O</span><br>      LogFormat <span class="hljs-string">&quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot; %I %O&quot;</span> combinedio<br>    &lt;/IfModule&gt;<br>    CustomLog <span class="hljs-string">&quot;logs/access_log&quot;</span> combined<br>&lt;/IfModule&gt;<br></code></pre></td></tr></table></figure><ul><li>变量参考<br>%h 客户端IP地址<br>%l 远程用户,启用mod_ident才有效，通常为减号“-”<br>%u 验证（basic，digest）远程用户,非登录访问时，为一个减号“-”<br>%t 服务器收到请求时的时间<br>%r First line of request，即表示请求报文的首行；记录了此次请求的“方法”，“URL”以及协议版本<br>%&gt;s 对于已在内部重定向的请求，这是原始请求的状态。使用%&gt;s 的最终状态。类型脚本中的exit 数字<br>%b 响应报文的大小，单位是字节；不包括响应报文http首部<br>%{Referer}i 请求报文中首部“referer”的值；即从哪个页面中的超链接跳转至当前页面。 { }里面内容就是报文中的一个键值对<br>%{User-Agent}i 请求报文中首部“User-Agent”的值；即发出请求的应用程序，多数为浏览器型号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#日志存放位置</span><br>[root@localhost ~]# <span class="hljs-built_in">ls</span> /var/log/httpd/<br>access_log  error_log/<br><span class="hljs-comment">#这个文件夹默认是软连接过来的</span><br>[root@localhost ~]# ll -d /etc/httpd/logs<br>lrwxrwxrwx. 1 root root 19 5月   2 09:30 /etc/httpd/logs -&gt; ../../var/log/httpd<br></code></pre></td></tr></table></figure><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="URI匹配规则"><a href="#URI匹配规则" class="headerlink" title="URI匹配规则"></a>URI匹配规则</h2><p>Apache httpd的URL匹配规则主要包括以下几种指令:<br><Location>: 基于URL路径进行匹配。<br><LocationMatch>: 使用正则表达式进行URL路径匹配。<br><Directory>: 基于服务器文件系统的目录路径进行匹配。<br><DirectoryMatch>: 使用正则表达式进行目录路径匹配。<br><Files>: 基于文件名进行匹配。<br><FilesMatch>: 使用正则表达式进行文件名匹配。</p><ul><li>优先级：<br>这些指令的优先级从高到低为:</li></ul><p><Files> 和 <FilesMatch><br><Directory> 和 <DirectoryMatch><br><Location> 和 <LocationMatch></p><ul><li>指令常用选项：</li></ul><p><Location> 指令:<br>    path: 指定需要匹配的 URL 路径。可以使用通配符。<br>    Order: 控制允许和拒绝操作的顺序。可以是 Allow,Deny 或 Deny,Allow。<br>    Allow: 指定允许访问的主机或 IP 地址。<br>    Deny: 指定拒绝访问的主机或 IP 地址。<br>    Require: 指定需要通过身份验证才能访问的用户或组。<br><LocationMatch> 指令:<br>    regex: 指定一个正则表达式来匹配 URL。<br>    其他选项同 <Location> 指令。<br><Directory> 指令:<br>    path: 指定需要匹配的目录路径。可以使用通配符。<br>    Options: 设置目录的访问选项,如 FollowSymLinks、Indexes 等。<br>    AllowOverride: 控制 .htaccess 文件的覆盖范围。<br>    其他选项同 <Location> 指令。<br><Files> 指令:<br>    filename: 指定需要匹配的文件名。可以使用通配符。<br>    其他选项同 <Location> 指令。<br><FilesMatch> 指令:<br>    regex: 指定一个正则表达式来匹配文件名。<br>    其他选项同 <Files> 指令</p><h2 id="Options指令"><a href="#Options指令" class="headerlink" title="Options指令"></a>Options指令</h2><p>后跟1个或多个以空白字符分隔的选项列表， 在选项前的+，- 表示增加或删除指定选项<br>常见选项（默认是全部禁用）：<br>    Indexes：指明的URL路径下不存在与定义的主页面资源相符的资源文件时，返回索引列表给用户<br>    FollowSymLinks：允许访问符号链接文件所指向的源文件<br>    None：全部禁用<br>    All： 全部允许</p><h2 id="AllowOverride指令"><a href="#AllowOverride指令" class="headerlink" title="AllowOverride指令"></a>AllowOverride指令</h2><p>AllowOverride指令与访问控制相关的哪些指令可以放在指定目录下的.htaccess（由AccessFileName 指令指定,AccessFileName .htaccess 为默认值）文件中，覆盖之前的配置指令，只对语句有效，直接在对应的文件目录中新建一个.htaccess的文件<br>常见用法：<br>    AllowOverride All:.htaccess中所有指令都有效<br>    AllowOverride None：.htaccess 文件无效，此为httpd 2.3.9以后版的默认值<br>    AllowOverride AuthConfig：.htaccess 文件中，除了AuthConfig 其它指令都无法生效，指定精确指令</p><h2 id="基于IP地址的访问控制"><a href="#基于IP地址的访问控制" class="headerlink" title="基于IP地址的访问控制"></a>基于IP地址的访问控制</h2><p>针对各种资源，可以基于以下两种方式的访问控制<br>    客户端来源地址<br>    用户账号<br>基于客户端的IP地址的访问控制<br>    无明确授权的目录，默认拒绝<br>    允许所有主机访问：Require all granted<br>    拒绝所有主机访问：Require all denied<br>    授权指定来源的IP访问：Require ip <IPADDR><br>    拒绝特定的IP访问：Require not ip <IPADDR><br>    授权特定主机访问：Require host <HOSTNAME><br>    拒绝特定主机访问：Require not host <HOSTNAME><br>需要注释掉Directory下的 Require all granted。在Directory标签下编辑。</p><h2 id="基于用户的访问控制"><a href="#基于用户的访问控制" class="headerlink" title="基于用户的访问控制"></a>基于用户的访问控制</h2><p>认证质询：WWW-Authenticate，响应码为401，拒绝客户端请求，并说明要求客户端需要提供账号和密码<br>认证：Authorization，客户端用户填入账号和密码后再次发送请求报文；认证通过时，则服务器发送响应的资源<br>认证方式两种<br>    basic：明文<br>    digest：消息摘要认证,兼容性差<br>安全域：需要用户认证后方能访问的路径；应该通过名称对其进行标识，以便于告知用户认证的原因用户的账号和密码<br>虚拟账号：仅用于访问某服务时用到的认证标识</p><h1 id="MPM多路处理模块"><a href="#MPM多路处理模块" class="headerlink" title="MPM多路处理模块"></a>MPM多路处理模块</h1><p>httpd 支持三种MPM工作模式：prefork, worker, event<br>prefork：多进程I&#x2F;O模型，一个主进程，管理多个子进程，一个子进程处理一个请求。<br>worker：复用的多进程I&#x2F;O模型，多进程多线程，一个主进程，管理多个子进程，一个子进程管理多个线程，每个 线程处理一个请求。<br>event：事件驱动模型，一个主进程，管理多个子进程，每个子进程创建多个线程，一个线程处理多个请求。</p><h2 id="prefork"><a href="#prefork" class="headerlink" title="prefork"></a>prefork</h2><p>Prefork MPM，这种模式采用的是预派生子进程方式，用单独的子进程来处理请求，子进程间互相独立，互不影响，大大的提高了稳定性，但每个进程都会占用内存，所以消耗系统资源过高。<br>Prefork MPM 工作原理：控制进程Master首先会生成“StartServers”个进程，“StartServers”可以在Apache主配置文件里配置，然后为了满足“MinSpareServers”设置的最小空闲进程个数，会建立一个空闲进程，等待一秒钟，继续创建两个空闲进程，再等待一秒钟，继续创建四个空闲进程，以此类推，会不断的递归增长创建进程，最大同时创建32个空闲进程，直到满足“MinSpareServers”设置的空闲进程个数为止。Apache的预派生模式不必在请求到来的时候创建进程，这样会减小系统开销以增加性能，不过Prefork MPM是基于多进程的模式工作的，每个进程都会占用内存，这样资源消耗也较高。</p><h2 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h2><p>Worker MPM是Apche 2.0版本中全新的支持多进程多线程混合模型的MPM，由于使用线程来处理HTTP请求，所以效率非常高，而对系统的开销也相对较低，Worker MPM也是基于多进程的，但是每个进程会生成多个线程，由线程来处理请求，这样可以保证多线程可以获得进程的稳定性；<br>Worker MPM工作原理： 控制进程Master在最初会建立“StartServers”个进程，然后每个进程会创建“ThreadPerChild”个线程，多线程共享该进程内的资源，同时每个线程独立的处理HTTP请求，为了不在请求到来的时候创建线程，Worker MPM也可以设置最大最小空闲线程，Worker MPM模式下同时处理的请求&#x3D;ThreadPerChild*进程数，也就是MaxClients，如果服务负载较高，当前进程数不满足需求，Master控制进程会fork新的进程，最大进程数不能超过ServerLimit数，如果需要，可以调整这些对应的参数，比如，如果要调整StartServers的数量，则也要调整 ServerLimit的值</p><h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>这个是 Apache中最新的模式，在现在版本里的已经是稳定可用的模式。它和 worker模式很像，最大的区别在于，它解决了 keep-alive 场景下 ，长期被占用的线程的资源浪费问题（某些线程因为被keep-alive，挂在那里等待，中间几乎没有请求过来，一直等到超时）。<br>event MPM中，会有一个专门的线程来管理这些 keep-alive 类型的线程，当有真实请求过来的时候，将请求传递给服务线程，执行完毕后，又允许它释放。这样，一个线程就能处理几个请求了，实现了异步非阻塞。<br>event MPM在遇到某些不兼容的模块时，会失效，将会回退到worker模式，一个工作线程处理一个请求。官方自带的模块，全部是支持event MPM的。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2025/10/28/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/10/28/HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h1><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于在客户端（通常是浏览器）和服务器之间传输超文本（如HTML）的应用层协议。它是无状态的、面向请求-响应的协议，基于TCP&#x2F;IP传输。</p><p>HTTP有不同版本号，不同版本号区别如下</p><ul><li>HTTP0.9：仅支持GET方法，仅能访问HTML格式的资源</li><li>HTTP1.0：增加POST和HEAD方法，MIME支持多种数据格式，开始支持Cache，支持tcp短连接</li><li>HTTP1.1：支持持久连接（长连接），一个TCP连接允许多个请求，新增PUT、PATCH、DELETE等</li><li>HTTP2.0：性能大幅提升，新的二进制格式，多路复用，header压缩，服务端推送。</li></ul><h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>HTTP的工作过程可以总结为以下几个步骤：</p><ul><li>建立连接： 客户端（如浏览器）与服务器之间通过TCP三次握手建立连接。</li><li>发送请求： 客户端向服务器(Apache、Nginx、IIS服务器)发送HTTP请求报文，请求资源或操作。</li><li>服务器处理请求： HTTP服务器接收到请求后，处理请求并生成响应。</li><li>返回响应： 服务器将响应报文返回给客户端。</li><li>断开连接： 通常在响应完成后关闭TCP连接（HTTP&#x2F;1.0默认短连接，HTTP&#x2F;1.1支持长连接）。</li></ul><h1 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h1><h2 id="URI（Uniform-Resource-Identifier）"><a href="#URI（Uniform-Resource-Identifier）" class="headerlink" title="URI（Uniform Resource Identifier）"></a>URI（Uniform Resource Identifier）</h2><p>URI是统一资源标识符，用于标识互联网上的资源。URI分为两种</p><ul><li>URL（Uniform Resource Locator）： 统一资源定位符，用于描述资源的地址。</li><li>URN（Uniform Resource Name）： 统一资源名称，用于标识资源的名称，不依赖物理位置</li></ul><h2 id="URL（Uniform-Resource-Locator"><a href="#URL（Uniform-Resource-Locator" class="headerlink" title="URL（Uniform Resource Locator"></a>URL（Uniform Resource Locator</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息<br>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：<br><a href="http://iproute.cn/news/search?keyword=123&enc=utf8#name=321">http://iproute.cn:80/news/search?keyword=123&amp;enc=utf8#name=321</a></p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ul><li>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符</li><li>域名(主机)部分：该URL的域名部分为“iproute.cn”。一个URL中，也可以使用IP地址作为域名使用</li><li>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li><li>虚拟目录部分：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”</li><li>文件名部分：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“search”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</li><li>参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“keyword&#x3D;123&amp;enc&#x3D;utf8”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li><li>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</li></ul><h1 id="HTTP注意事项"><a href="#HTTP注意事项" class="headerlink" title="HTTP注意事项"></a>HTTP注意事项</h1><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><h1 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h1><ul><li>HTTP是基于客户端&#x2F;服务端（C&#x2F;S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求&#x2F;响应协议。</li><li>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</li><li>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</li><li>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</li><li>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</li></ul><h2 id="常见http请求报文头部属性"><a href="#常见http请求报文头部属性" class="headerlink" title="常见http请求报文头部属性"></a>常见http请求报文头部属性</h2><ul><li>Accpet<br>– 告诉服务端,客户端接收什么类型的响应</li><li>Referer<br>– 表示这是请求是从哪个URL进来的,比如想在网上购物,但是不知道选择哪家电商平台,你就去问百度,说哪家电商的东西便宜啊,然后一堆东西弹出在你面前,第一给就是某宝,当你从这里进入某宝的时候,这个请求报文的Referer就是<a href="http://www.baidu.com/">www.baidu.com</a></li><li>Cache-Control<br>– 对缓存进行控制,如一个请求希望响应的内容在客户端缓存一年,或不被缓可以通过这个报文头设置</li><li>Accept-Encoding<br>– 这个属性是用来告诉服务器能接受什么编码格式,包括字符编码,压缩形式(一般都是压缩形式)<br>– 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)</li><li>Host<br>– 指定要请求的资源所在的主机和端口</li><li>User-Agent<br>– 告诉服务器，客户端使用的操作系统、浏览器版本和名称</li><li>更多的头部属性可以参见脚本之家提供的http请求头部大全<br>– <a href="http://tools.jb51.net/table/http_header">http://tools.jb51.net/table/http_header</a></li></ul><h2 id="POST和GET请求方法区别"><a href="#POST和GET请求方法区别" class="headerlink" title="POST和GET请求方法区别"></a>POST和GET请求方法区别</h2><ul><li>提交的过程<br>– GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接<br>– POST提交：把提交的数据放置在是HTTP包的包体中</li><li>传输数据的大小<br>– 首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制<br>– GET提交，特定浏览器和服务器对URL长度有限制<br>– POST提交，由于不是通过URL传值，理论上数据不受限</li><li>安全性<br>– POST的安全性要比GET的安全性高<br>– 登录页面有可能被浏览器缓存，而缓存的是URL<br>– 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了<br>– 使用GET提交数据还可能会造成Cross-site request forgery攻击</li></ul><h2 id="常见http响应报文头部属性"><a href="#常见http响应报文头部属性" class="headerlink" title="常见http响应报文头部属性"></a>常见http响应报文头部属性</h2><ul><li>Cache-Control<br>– 响应输出到客户端后,服务端通过该属性告诉客户端该怎么控制响应内容的缓存</li><li>ETag<br>– 表示你请求资源的版本,如果该资源发生啦变化,那么这个属性也会跟着变</li><li>Location<br>– 在重定向中或者创建新资源时使用</li><li>Set-Cookie<br>– 服务端可以设置客户端的cookie</li><li>更多的头部属性可以参见脚本之家提供的http请求头部大全<br>– <a href="http://tools.jb51.net/table/http_header">http://tools.jb51.net/table/http_header</a></li></ul><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><ul><li><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br>– 1xx：指示信息–表示请求已接收，继续处理<br>– 2xx：成功–表示请求已被成功接收、理解、接受<br>– 3xx：重定向–要完成请求必须进行更进一步的操作<br>– 4xx：客户端错误–请求有语法错误或请求无法实现<br>– 5xx：服务器端错误–服务器未能实现合法的请求</p></li><li><p>常见状态码</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">200 OK                        //客户端请求成功<br>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 <br>403 Forbidden                 //服务器收到请求，但是拒绝提供服务<br>404 Not Found                 //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error     //服务器发生不可预期的错误<br>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br></code></pre></td></tr></table></figure><ul><li>更多状态码属性可以参见脚本之家提供的状态码大全<br>– <a href="http://tools.jb51.net/table/http_status_code">http://tools.jb51.net/table/http_status_code</a></li></ul><h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><ul><li>GET 请求指定的页面信息，并返回实体主体。</li><li>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li><li>PUT 从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE 请求服务器删除指定的页面。</li><li>CONNECT HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS 允许客户端查看服务器的性能。</li><li>TRACE 回显服务器收到的请求，主要用于测试或诊断。</li><li>更多http请求方法可以参见脚本之家提供的http请求方法大全<br>– <a href="http://tools.jb51.net/table/http_request_method">http://tools.jb51.net/table/http_request_method</a></li></ul><h1 id="HTTP工作原理-1"><a href="#HTTP工作原理-1" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ul><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>释放 TCP连接;</li><li>浏览器将该 html 文本并显示内容;</li></ul><h1 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h1><p>HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据；相反的就是短连接。<br>在实际使用中，HTTP头部有了Keep-Alive这个值并不代表一定会使用长连接，客户端和服务器端都可以无视这个值，也就是不按标准来。毕竟TCP是一个双向连接的协议，双方都可以决定是不是主动断开。<br>客户端的长连接不可能无限期的拿着，会有一个超时时间，服务器有时候会告诉客户端超时时间。下图中的Keep-Alive: timeout&#x3D;20，表示这个TCP通道可以保持20秒</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NFS网络文件共享</title>
    <link href="/2025/10/28/NFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <url>/2025/10/28/NFS%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="NFS网络文件共享"><a href="#NFS网络文件共享" class="headerlink" title="NFS网络文件共享"></a>NFS网络文件共享</h1><p>NFS（Network File System）是一种分布式文件系统协议，最初由Sun Microsystems在1984年开发。NFS允许计算机在网络上共享文件和目录，就像这些文件和目录位于本地计算机上一样。它广泛应用于UNIX和类UNIX系统中，但也可以在其他操作系统上使用，如Windows和macOS。</p><h2 id="NFS简介与RPC简介"><a href="#NFS简介与RPC简介" class="headerlink" title="NFS简介与RPC简介"></a>NFS简介与RPC简介</h2><h3 id="NFS服务介绍"><a href="#NFS服务介绍" class="headerlink" title="NFS服务介绍"></a>NFS服务介绍</h3><p>NFS是一种网络协议，NFS依赖RPC才能工作。<br>NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。可以理解为把一个电脑上的硬盘挂载到另一个电脑上使用，另一个电脑能够像使用自己本地硬盘使用挂载的硬盘。<br>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责信息的传输。</p><h3 id="RPC协议介绍"><a href="#RPC协议介绍" class="headerlink" title="RPC协议介绍"></a>RPC协议介绍</h3><p>RPC（Remote Procedure Call）远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。其工作在TCP&#x2F;UDP的111端口。建立在Socket之上的，主要是简化编程的工作在底层提供网络之间的通信。<br>RPC采用客户机&#x2F;服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p><h4 id="RPC-远程过程调度"><a href="#RPC-远程过程调度" class="headerlink" title="RPC 远程过程调度"></a>RPC 远程过程调度</h4><ul><li>NFS 协议本身并没有网络传输功能，而是基于远程过程调用协议实现的</li><li>提供一个面向过程的远程服务的接口</li><li>可以通过网络从远程主机程序上请求服务，而不需要了解底层网络技术的协议</li><li>工作在 OSI 模型的会话层，它可以为遵从 RPC 协议应用层协议提供端口注册功能</li><li>事实上，有很多服务（NFS 和 NIS 等）都可以向 RPC 注册端口</li><li>RPC 使用网络端口 111 来监听客户端的请求</li></ul><h4 id="RPC-协议模型"><a href="#RPC-协议模型" class="headerlink" title="RPC 协议模型"></a>RPC 协议模型</h4><ul><li>基于 rpc 的服务（此处是指 nfs 服务，在别处有可能是代表其他服务）在启动时向 portmapper 注册端口</li><li>基于 rpc 的客户端联系服务端 portmapper 询问服务的端口号<br>p- ortmapper 告知客户端基于 rpc 服务使用的端口号</li><li>基于 rpc 的客户端访问被告知单某基于 rpc 服务的端口</li><li>基于 rpc 的服务响应客户端的请求</li></ul><h3 id="NFS工作流程"><a href="#NFS工作流程" class="headerlink" title="NFS工作流程"></a>NFS工作流程</h3><ul><li>首先服务器端启动RPC服务，并开启111端口</li><li>然后还需要服务器端启动NFS服务，并向RPC注册端口信息</li><li>客户端启动RPC（portmap服务），向服务端的RPC(portmap)服务请求服务端的NFS端口</li><li>服务端的RPC(portmap)服务反馈NFS端口信息给客户端。</li><li>客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输。</li></ul><h3 id="挂载原理-过程"><a href="#挂载原理-过程" class="headerlink" title="挂载原理&#x2F;过程"></a>挂载原理&#x2F;过程</h3><p>当我们在NFS服务器设置好一个共享目录&#x2F;opt 后，其他人是有权访问&#x2F;opt这个共享目录的，NFS客户端就可以将这个目录挂载到自己文件系统的某个挂载点（这个挂载点可以自己定义），路径不同也可以；如下图客户端A与客户端B挂载的目录就不相同。并且挂载好后我们在本地能够看到服务端&#x2F;opt下的所有数据。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSH远程管理协议</title>
    <link href="/2025/10/28/SSH%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/10/28/SSH%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH协议-OpenSSH服务"><a href="#SSH协议-OpenSSH服务" class="headerlink" title="SSH协议&#x2F;OpenSSH服务"></a>SSH协议&#x2F;OpenSSH服务</h1><p>SSH（Secure Shell）协议是一种网络协议，用于加密方式远程登录到服务器。它提供了一种安全的方法来传输数据，防止数据在传输过程中被窃听或篡改。SSH协议不仅用于远程登录，还可用于远程执行命令、文件传输（SFTP）、端口转发等<br>OpenSSH是SSH协议的一个开源实现工具，由OpenBSD项目开发和维护。它是大多数Unix和类Unix操作系统中默认的SSH实现，包括Linux、macOS和FreeBSD等。<br>OpenSSH提供了服务端程序(openssh-server)和客户端工具(openssh-client)<br>Mac和Linux中默认已安装ssh客户端，可直接在终端中使用ssh命令<br>Windows需手动安装ssh客户端，较常用的Windows SSH客户端有PuTTY和XShell<br>SSH能够提供两种安全验证的方法：</p><ul><li>基于口令的验证—用账户和密码来验证登录</li><li>基于密钥的验证—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全</li></ul><h1 id="SSH客户端使用"><a href="#SSH客户端使用" class="headerlink" title="SSH客户端使用"></a>SSH客户端使用</h1><p>OpenSSH服务提供我们SSH工具，该工具采用SSH协议来连接到远程主机上。</p><h2 id="SSH常用操作"><a href="#SSH常用操作" class="headerlink" title="SSH常用操作"></a>SSH常用操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#通过SSH协议登录远程主机</span><br>[root@localhost ~]# ssh root@192.168.88.20<br><br><span class="hljs-comment">#指定连接远程主机的端口号(SSH默认连接的端口号为22，如果修改过端口号，可以通过以下方式连接，-p后面不能有空格)</span><br>[root@localhost ~]# ssh root@192.168.88.20 -P22<br><br><span class="hljs-comment">#不登陆到远程主机中，仅仅执行某个命令并返回结果</span><br>[root@localhost ~]# ssh root@192.168.88.20 <span class="hljs-built_in">ls</span> -lah /etc<br><br><span class="hljs-comment">#查看已经连接过主机的记录(会看到ssh客户端产生的公钥信息)</span><br>[root@localhost ~]# <span class="hljs-built_in">cat</span> .ssh/known_hosts<br></code></pre></td></tr></table></figure><h2 id="SCP远程文件传输"><a href="#SCP远程文件传输" class="headerlink" title="SCP远程文件传输"></a>SCP远程文件传输</h2><p>除了连接到远程主机之外，我们也可以用附带的小工具SCP来进行远程文件传输和下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将本地文件复制给远程主机，-r递归复制整个目录，-p保留源文件的时间和权限属性</span><br>[root@localhost ~]# <span class="hljs-built_in">touch</span> file<br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I am server1&quot;</span> &gt; file<br>[root@localhost ~]# scp -P22 -r -p /root/file <br><br><span class="hljs-comment">#将远程主机上的文件下载到本地</span><br>[root@localhost ~]# scp -P22 -r -p root@192.168.88.20:/tmp/file /root/<br><br><span class="hljs-comment">#SSH客户端自带SFTP功能，可以直接通过FTP协议进行文件传递</span><br>[root@localhost ~]# sftp -oPort=22 root@192.168.88.20<br></code></pre></td></tr></table></figure><h1 id="SSH配置文件"><a href="#SSH配置文件" class="headerlink" title="SSH配置文件"></a>SSH配置文件</h1><ul><li>sshd服务的配置信息保存在&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件中。运维人员一般会把保存着最主要配置信息的文件称为主配置文件，而配置文件中有许多以井号开头的注释行，要想让这些配置参数生效，需要在修改参数后再去掉前面的井号</li><li>sshd服务配置文件中包含的参数以及作用<table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Port 22</td><td align="left">默认的sshd服务端口</td></tr><tr><td align="left">ListenAddress 0.0.0.0</td><td align="left">设定sshd服务器监听的IP地址</td></tr><tr><td align="left">Protocol 2</td><td align="left">SSH协议的版本号</td></tr><tr><td align="left">HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_key</td><td align="left">SSH协议版本为1时，DES私钥存放的位置</td></tr><tr><td align="left">HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key</td><td align="left">SSH协议版本为2时，RSA私钥存放的位置</td></tr><tr><td align="left">HostKey &#x2F;etc&#x2F;ssh&#x2F;ssh_host_dsa_key</td><td align="left">SSH协议版本为2时，DSA私钥存放的位置</td></tr><tr><td align="left">PermitRootLogin yes</td><td align="left">设定是否允许root管理员直接登录</td></tr><tr><td align="left">StrictModes yes</td><td align="left">当远程用户的私钥改变时直接拒绝连接</td></tr><tr><td align="left">MaxAuthTries 6</td><td align="left">最大密码尝试次数</td></tr><tr><td align="left">MaxSessions 10</td><td align="left">最大终端数</td></tr><tr><td align="left">PasswordAuthentication yes</td><td align="left">是否允许密码验证</td></tr><tr><td align="left">PubkeyAuthentication yes</td><td align="left">是否允许使用公钥进行身份验证</td></tr></tbody></table></li></ul><h1 id="安全密钥验证"><a href="#安全密钥验证" class="headerlink" title="安全密钥验证"></a>安全密钥验证</h1><p>上面讲到，ssh远程连接，除了使用密码的方式登录，还可以使用密钥对(公钥和私钥)进行登录。相比于密码等于而言，密钥登录会更加的安全<br>如果使用公钥和私钥进行加密，那么我们称之为是一种非对称加密的方式进行加密。<br>非对称加密是一种加密方式，它涉及到两个密钥：一个公钥和一个私钥。公钥可以公开给任何人，而私钥则必须保密，只有密钥的拥有者才知道。这种加密方式的特点是使用公钥加密的数据只能通过对应的私钥来解密，反之亦然，使用私钥加密的数据只能通过对应的公钥来解密。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ul><li>密钥生成：首先生成一对密钥，一个公钥和一个私钥。这两个密钥是数学上相关的，但即使知道其中一个，也很难计算出另一个。</li><li>加密：发送方使用接收方的公钥来加密信息。这个过程是可逆的，但只有拥有正确私钥的人才能解密。</li><li>解密：接收方使用自己的私钥来解密信息。这个过程确保了只有拥有私钥的接收方才能阅读信息。</li></ul><p>我们可以想象一下，你有一个非常特别的邮箱，这个邮箱有一个特点：它有两个锁。一个锁是公开的，任何人都可以往里投信，但只有你知道如何打开它（私钥）。另一个锁是私有的，只有你知道它在哪里，而且只有你拥有打开它的钥匙（公钥）。</p><ul><li>公钥（锁）：你把这个特别的锁（公钥）放在一个公共的地方，比如你的家门口。任何人都可以给你写信，他们只需要用这个锁把你的信锁起来，然后投进你的邮箱。因为只有你知道如何打开这个锁，所以你的信件在运输过程中是安全的。</li><li>私钥（钥匙）：你把打开这个锁的钥匙（私钥）藏在家里一个安全的地方。当信件到达时，你可以用你的私钥打开锁，取出信件阅读。</li><li>安全性：即使有人试图复制这个锁（公钥），他们也无法制造出能打开它的钥匙（私钥），因为这两个是数学上相关的，但计算其中一个从另一个是几乎不可能的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PTF文件服务器</title>
    <link href="/2025/10/28/PTF%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2025/10/28/PTF%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="FTP-File-Transfer-Protocol"><a href="#FTP-File-Transfer-Protocol" class="headerlink" title="FTP(File Transfer Protocol)"></a>FTP(File Transfer Protocol)</h1><p>FTP（File Transfer Protocol）是用于在计算机网络中进行文件传输的协议。它使用客户端-服务器模式，允许文件在客户端和服务器之间上传或下载。FTP 服务通常用于在不同主机间传输大容量文件，特别是在网络环境中需要频繁进行文件交换时。<br>FTP运行在OSI模型的应用层，并利用传输协议TCP在不同的主机之间提供可靠的数据传输。并且在文件传输中FTP还支持断点续传功能，可以大幅度减少CPU网络带宽的开销。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>FTP 使用客户端与服务器之间的通信来传输文件。它通过两条连接来工作：一条用于命令传输（控制连接），另一条用于数据传输（数据连接）。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul><li><p>端口 21：控制连接端口<br>– 功能：FTP 的控制连接使用端口 21。这条连接用于客户端与服务器之间交换命令和响应。当你在 FTP 客户端中输入命令（例如 LIST、RETR、STOR）时，这些命令是通过端口 21 发送的。<br>– 数据流向：控制连接是全双工的，客户端和服务器都可以发送消息，但所有数据传输操作（如文件上传、下载）都不会通过控制连接进行。</p></li><li><p>端口 20：数据连接端口<br>– 功能：端口 20 在 FTP 协议中用于数据传输连接，特别是在 主动模式（PORT 模式）下。它用于通过数据连接传输实际的文件数据。<br>– 数据流向：当 FTP 客户端在_主动模式_下与服务器建立连接时，服务器通过端口 20 向客户端的指定端口发起数据连接。这条连接用于传输文件内容。</p></li></ul><h2 id="FTP-模式"><a href="#FTP-模式" class="headerlink" title="FTP 模式"></a>FTP 模式</h2><p>FTP 支持两种不同的模式：主动模式（PORT）和被动模式（PASV）。<br>21端口用于控制连接，20端口用于数据连接。数据连接的传输方式有主动模式和被动模式。主动模式下由服务器的20端口向客户端的随机端口进行连接，适用于客户端有公网ip无防火墙限制。被动模式由客户端向服务器的随机端口进行连接，适用于客户端无法直接连接或者服务器没有固定端口。</p><h3 id="主动模式（Active-Mode）"><a href="#主动模式（Active-Mode）" class="headerlink" title="主动模式（Active Mode）"></a>主动模式（Active Mode）</h3><p>在主动模式下，客户端向服务器发起连接请求，服务器在数据传输时主动连接客户端。具体来说，客户端使用端口 21 与服务器建立控制连接，而数据连接则由服务器从端口 20 发起到客户端的指定端口。</p><h4 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h4><ul><li><p>建立控制连接：<br>– 客户端通过任意端口（例如随机的高端口，通常是 1024 以上的端口）向服务器的端口21发起连接，建立控制连接。这个连接用于发送 FTP 命令和接收响应。</p></li><li><p>客户端发送命令：<br>– 客户端通过控制连接发送 FTP 命令（如 USER、PASS、LIST 等），请求服务器执行操作。</p></li><li><p>客户端告诉服务器监听的端口：<br>– 当客户端希望传输文件时，它会告诉服务器自己希望通过哪个端口进行数据传输。这是通过 PORT 命令 完成的。客户端指定了一个端口（例如 1026）供服务器使用。</p></li><li><p>服务器发起数据连接：<br>– 服务器收到客户端的 PORT 命令 后，会使用 端口 20 连接到客户端指定的端口（例如 1026）。这条连接用于传输数据，如文件内容或目录列表。</p></li><li><p>数据传输：<br>– 一旦服务器与客户端的指定端口建立数据连接后，数据传输就开始了。文件会通过这个数据连接进行传输。</p></li><li><p>断开数据连接：<br>– 数据传输完成后，数据连接会关闭，控制连接保持打开，直到用户结束会话（通过 QUIT 命令）。</p></li><li><p>缺点：如果客户端位于 NAT 或防火墙后面，客户端很难接受来自服务器的入站连接。由于 NAT 会改变客户端的 IP 地址和端口，服务器可能无法正确连接到客户端。</p></li></ul><h3 id="被动模式（Passive-Mode）"><a href="#被动模式（Passive-Mode）" class="headerlink" title="被动模式（Passive Mode）"></a>被动模式（Passive Mode）</h3><p>在被动模式下，服务器不会主动连接客户端，而是客户端主动与服务器建立数据连接。服务器会提供一个端口范围，客户端可以通过控制连接（端口 21）请求服务器提供一个可用端口，客户端再通过这个端口与服务器建立数据连接。</p><h4 id="连接过程-1"><a href="#连接过程-1" class="headerlink" title="连接过程"></a>连接过程</h4><ul><li><p>建立控制连接：<br>– 客户端首先向服务器的 端口 21 发起连接，建立控制连接。这个过程和主动模式相同。</p></li><li><p>客户端请求服务器进入被动模式：<br>– 客户端发送 PASV 命令，请求服务器进入被动模式。此时，服务器会选择一个高端口（通常在 1024 以上），并向客户端返回该端口的信息。例如，服务器可能返回 227 Entering Passive Mode (192,168,1,2 120,232)，这意味着服务器的 IP 地址是 192.168.1.2，并且它希望客户端连接到端口 29832。</p></li><li><p>客户端连接到服务器的被动端口：<br>– 客户端接收到服务器返回的 IP 地址和端口信息后，会从任意端口连接到服务器提供的被动端口（例如 29832）。这条连接用于文件数据的传输。</p></li><li><p>数据传输：<br>– 一旦数据连接建立，客户端和服务器就可以通过该连接传输文件数据或目录列表。</p></li><li><p>断开数据连接：<br>– 数据传输完成后，数据连接会关闭。控制连接仍然保持打开，直到用户结束会话（通过 QUIT 命令）。</p></li><li><p>优点：被动模式解决了客户端处于 NAT 或防火墙后面时的问题，因为客户端只需要发起对服务器的外向连接，不需要接受来自服务器的入站连接。</p></li><li><p>缺点：服务器需要预先开放一个端口范围，并且在某些情况下，如果服务器的防火墙配置不当，仍然可能会遇到问题。</p></li></ul><h1 id="FTP常用服务软件"><a href="#FTP常用服务软件" class="headerlink" title="FTP常用服务软件"></a>FTP常用服务软件</h1><p>许多操作系统和第三方软件都提供 FTP 服务的实现。常见的 FTP 服务器软件有：</p><ul><li>vsftpd（Very Secure FTP Daemon）：在 Linux 上广泛使用的高安全性 FTP 服务器。</li><li>ProFTPD：功能丰富的 FTP 服务，支持多种认证机制。</li><li>Pure-FTPd：简单易用的 FTP 服务器，适用于 Unix&#x2F;Linux 系统。</li><li>FileZilla Server：在 Windows 上使用的开源 FTP 服务器。</li></ul><h2 id="vsftpd介绍"><a href="#vsftpd介绍" class="headerlink" title="vsftpd介绍"></a>vsftpd介绍</h2><ul><li>软件包：vsftpd</li><li>服务类型：由Systemd启动的守护进程</li><li>配置单元：&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vsftpd.service</li><li>守护进程：&#x2F;usr&#x2F;sbin&#x2F;vsftpd</li><li>端口：21(ftp),20(ftp‐data)</li><li>主配置文件：&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf</li><li>用户访问控制配置文件：&#x2F;etc&#x2F;vsftpd&#x2F;ftpusers &#x2F;etc&#x2F;vsftpd&#x2F;user_list</li><li>日志文件：&#x2F;etc&#x2F;logrotate.d&#x2F;vsftpd<br>配置文件参数<table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">listen&#x3D;NO</td><td align="left">是否以独立运行的方式监听服务</td></tr><tr><td align="left">listen_address&#x3D;ip地址</td><td align="left">设置要监听的IP地址</td></tr><tr><td align="left">listen_port&#x3D;21</td><td align="left">设置FTP服务的监听端口</td></tr><tr><td align="left">download_enable&#x3D;YES</td><td align="left">是否允许下载文件</td></tr><tr><td align="left">userlist_enable&#x3D;YES</td><td align="left">设置用户列表为”允许”</td></tr><tr><td align="left">userlist_deny&#x3D;YES</td><td align="left">设置用户列表为”禁止”</td></tr><tr><td align="left">max_clients&#x3D;0</td><td align="left">最大客户端连接数，0为不限制</td></tr><tr><td align="left">max_per_ip&#x3D;0</td><td align="left">同一IP地址的最大连接数，0为不限制</td></tr><tr><td align="left">anonymous_enable&#x3D;YES</td><td align="left">是否允许匿名用户访问</td></tr><tr><td align="left">anon_upload_enable&#x3D;YES</td><td align="left">是否允许匿名用户上传文件</td></tr><tr><td align="left">anon_umask</td><td align="left">匿名用户上传文件的umask</td></tr><tr><td align="left">anon_root&#x3D;&#x2F;var&#x2F;ftp</td><td align="left">匿名用户的ftp根目录</td></tr><tr><td align="left">anon_mkdir_write_enable&#x3D;YES</td><td align="left">是否允许匿名用户创建目录</td></tr><tr><td align="left">anon_other_write_enable&#x3D;YES</td><td align="left">是否开放匿名用户的其他写入权限（重命名、删除等）</td></tr><tr><td align="left">anon_max_rate&#x3D;0</td><td align="left">匿名用户的最大传输速率，0为不限制</td></tr><tr><td align="left">local_enable&#x3D;yes</td><td align="left">是否允许本地用户登录</td></tr><tr><td align="left">local_umask&#x3D;022</td><td align="left">本地用户上传文件的umask值</td></tr><tr><td align="left">local_root&#x3D;&#x2F;vat&#x2F;ftp</td><td align="left">本地用户的ftp根目录</td></tr><tr><td align="left">chroot_local_user&#x3D;YES</td><td align="left">是否将用户权限禁锢在ftp目录，以确保安全</td></tr><tr><td align="left">local_max_rate&#x3D;0</td><td align="left">本地用户的最大传输速率，0为不限制</td></tr></tbody></table></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Samba文件共享</title>
    <link href="/2025/10/28/Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <url>/2025/10/28/Samba%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Samba文件共享"><a href="#Samba文件共享" class="headerlink" title="Samba文件共享"></a>Samba文件共享</h1><h2 id="什么是Samba"><a href="#什么是Samba" class="headerlink" title="什么是Samba"></a>什么是Samba</h2><p>Samba 是一个开源软件套件，允许 Linux&#x2F;Unix 系统与 Windows 系统之间实现文件共享和打印服务。Samba 使用 SMB（Server Message Block）&#x2F;CIFS（Common Internet File System）协议，这些协议是 Windows 系统共享资源的基础。</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>1992 年：Samba 项目由 Andrew Tridgell 发起，最初作为一个简单工具来查看 DOS 文件共享。<br>1994 年：Samba 正式命名，支持 SMB 协议。<br>1996 年：开始支持 Windows NT 域。<br>2003 年：引入 LDAP 集成，支持 Active Directory。<br>2012 年：Samba 4 发布，完全实现了 Active Directory 的功能。<br>现在：Samba 成为企业级跨平台文件共享的核心工具之一。</p><h2 id="Samba用途"><a href="#Samba用途" class="headerlink" title="Samba用途"></a>Samba用途</h2><p>文件共享：允许用户在不同操作系统之间共享文件。<br>打印服务：提供跨平台的打印服务和在线编辑。<br>域控制器：Samba 可以用作 Windows 网络的域控制器。<br>认证与授权：支持用户认证、访问控制和权限管理。<br>跨平台互操作性：让 Linux&#x2F;Unix 系统与 Windows 系统无缝协作。</p><p>Windows计算机网络管理模式：</p><ul><li>工作组WORKGROUP：计算机对等关系，帐号信息各自管理</li><li>域DOMAIN：C&#x2F;S结构，帐号信息集中管理，DC,AD</li></ul><h2 id="Samba相关软件包介绍"><a href="#Samba相关软件包介绍" class="headerlink" title="Samba相关软件包介绍"></a>Samba相关软件包介绍</h2><p>在 Rocky Linux 中，Samba 的核心组件包含以下软件包：<br>samba：Samba 的主包，包括核心服务和工具。<br>samba-client：提供客户端工具，用于访问远程的 SMB&#x2F;CIFS 共享。<br>samba-common：共享的配置文件和库。<br>samba-libs：Samba 运行所需的库。<br>samba-common-tools：包含测试和管理工具，例如 smbstatus。<br>smbclient：命令行工具，用于访问 SMB&#x2F;CIFS 共享。<br>cifs-utils：提供挂载 SMB 文件系统的工具（如 mount.cifs）。</p><h2 id="相关服务进程"><a href="#相关服务进程" class="headerlink" title="相关服务进程"></a>相关服务进程</h2><p>smbd：提供文件共享和打印服务，TCP：139、445。<br>nmbd：负责 NetBIOS 名称解析和浏览功能，UDP：137、138。<br>winbindd：用于与 Windows 域集成，支持用户和组的认证。<br>samba-ad-dc：Samba 4 中的域控制器服务。</p><h2 id="Samba主配置文件"><a href="#Samba主配置文件" class="headerlink" title="Samba主配置文件"></a>Samba主配置文件</h2><p>主配置文件：&#x2F;etc&#x2F;samba&#x2F;smb.conf 帮助参看：man smb.conf<br>语法检查： testparm [-v] [&#x2F;etc&#x2F;samba&#x2F;smb.conf]</p><p>[global]<br>   workgroup &#x3D; WORKGROUP        # 工作组名称<br>   server string &#x3D; Samba Server # 服务器描述<br>   security &#x3D; user              # 认证模式<br>   log file &#x3D; &#x2F;var&#x2F;log&#x2F;samba&#x2F;log.%m # 日志文件路径<br>   max log size &#x3D; 50            # 最大日志文件大小（KB）<br>   dns proxy &#x3D; no               # 禁用 DNS 代理</p><p>[shared]<br>   path &#x3D; &#x2F;srv&#x2F;samba&#x2F;shared      # 共享路径<br>   browseable &#x3D; yes              # 是否可浏览<br>   writable &#x3D; yes                # 是否可写<br>   valid users &#x3D; @smbgroup       # 允许访问的用户&#x2F;组</p><h3 id="全局设置（-global-）"><a href="#全局设置（-global-）" class="headerlink" title="全局设置（[global]）"></a>全局设置（[global]）</h3><ul><li>workgroup：指定工作组名称，默认是 WORKGROUP。</li><li>security：<br>– user：用户级认证（常用）。<br>– share：共享级认证（不推荐）。<br>– domain：域级认证。<br>– ads：Active Directory 服务。</li><li>log file：日志文件路径。</li><li>max log size：限制日志文件大小。</li></ul><h3 id="共享设置（-共享名-）"><a href="#共享设置（-共享名-）" class="headerlink" title="共享设置（[共享名]）"></a>共享设置（[共享名]）</h3><ul><li>path：共享目录的路径。</li><li>browseable：决定共享是否可被浏览。</li><li>writable：是否允许写入。</li><li>valid users：指定允许访问的用户或组。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux企业服务</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>管道与重定向</title>
    <link href="/2025/10/26/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2025/10/26/%E7%AE%A1%E9%81%93%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I&#x2F;O重定向"></a>I&#x2F;O重定向</h1><p>I&#x2F;O对应系统中的输入(input)和输出(output)</p><p>其中输入可以是键盘输入，鼠标输入等等。同样输出也可以输出到终端中或者文件中</p><p>对于Linux系统，我们常见的输入输出的类型有：</p><ul><li>标准输入 0</li><li>标准正确输出 1</li><li>标准错误输出 2</li></ul><h2 id="File-Descriptors-FD，文件描述符"><a href="#File-Descriptors-FD，文件描述符" class="headerlink" title="File Descriptors(FD，文件描述符 )"></a>File Descriptors(FD，文件描述符 )</h2><table><thead><tr><th>Number</th><th>Channel name</th><th>Description</th><th>Default connection</th><th>Usage</th></tr></thead><tbody><tr><td>0</td><td>stdin</td><td>标准输入</td><td>键盘</td><td>只读</td></tr><tr><td>1</td><td>stdout</td><td>标准输出</td><td>命令行</td><td>只写</td></tr><tr><td>2</td><td>stderr</td><td>标准错误</td><td>命令行</td><td>只写</td></tr><tr><td>3+</td><td>filename</td><td>其他文件</td><td>none</td><td>读and&#x2F;or写</td></tr></tbody></table><p>文件描述符是操作系统内部用于管理和跟踪打开的文件和I&#x2F;O资源。比如当我们打开一个文件的时候，操作系统会分配一个文件描述符给这个文件，我们可以通过这个文件描述符来对文件进行读写等操作。</p><p>每个进程默认打开三个文件描述符：</p><ul><li>0：标准输入（stdin）</li><li>1：标准输出（stdout）</li><li>2：标准错误输出（stderr）</li></ul><h1 id="输出重定向-覆盖-追加"><a href="#输出重定向-覆盖-追加" class="headerlink" title="输出重定向(覆盖,追加)"></a>输出重定向(覆盖,追加)</h1><ul><li><blockquote><p>：覆盖重定向</p></blockquote></li><li><blockquote><blockquote><p>：追加重定向</p></blockquote></blockquote></li><li>1&gt;：覆盖重定向正确的输出数据流</li><li>1&gt;&gt;：追加重定向正确的输出数据流</li><li>2&gt;：覆盖重定向错误输出数据流</li><li>2&gt;&gt;：追加重定向错误输出数据流</li></ul><h1 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h1><p>标准输入：&lt; 等价 0&lt;</p><h1 id="进程管道"><a href="#进程管道" class="headerlink" title="进程管道"></a>进程管道</h1><p>用法：command1 | command2 | command3 | ….</p><h1 id="tee管道"><a href="#tee管道" class="headerlink" title="tee管道"></a>tee管道</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">du</span> -h . | <span class="hljs-built_in">sort</span> -hr | <span class="hljs-built_in">tee</span> file_sizes.txt<br>44K     .<br>0       ./dir1<br>0       ./dir<br><span class="hljs-comment">#使用 du 命令列出当前目录下的文件大小,然后通过管道传递给 sort 命令进行降序排序。最后使用 tee 命令将排序结果同时输出到终端和 file_sizes.txt 文件中。这样既可以在终端查看结果,也可以保存一份供后续分析使用</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计划任务与日志</title>
    <link href="/2025/10/26/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%97%A5%E5%BF%97/"/>
    <url>/2025/10/26/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%B8%8E%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><p>计划任务主要是做一些周期性的任务，可以让某个任务按照我们的预期的时间或计划去执行。</p><h2 id="单次调度执行at"><a href="#单次调度执行at" class="headerlink" title="单次调度执行at"></a>单次调度执行at</h2><p>安装at软件包：<br>yum install -y at</p><p>启动at服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# systemctl start atd<br>[root@localhost ~]# systemctl <span class="hljs-built_in">enable</span> atd        <span class="hljs-comment"># 开机自启动</span><br></code></pre></td></tr></table></figure><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p>at [options] time</p><h4 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h4><ul><li>-f：指定包含具体指令的任务文件</li><li>-q：指定新任务的队列名称</li><li>-l：显示待执行任务的列表</li><li>-d：删除指定的待执行任务</li><li>-c：根据序号查看具体任务的内容</li></ul><p>或者也可以使用一下命令查看和删除</p><ul><li>atq：查看待执行的任务</li><li>atrm：通过序号删除任务</li></ul><h4 id="timespec"><a href="#timespec" class="headerlink" title="timespec"></a>timespec</h4><p>at now +5min            # 从现在开始5分钟后<br>at teatime tomorrow  # 明天的下午16：00<br>at noon +4 days        # 4天后的中午<br>at 11:20 AM            # 早上11：20<br>  …..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#5分钟后创建一个文件</span><br>[root@localhost ~]# at now +5min<br>at&gt; <span class="hljs-built_in">touch</span> /root/file2<br>at&gt; &lt;EOT&gt;            <span class="hljs-comment"># ctrl+D 结束任务编辑</span><br>job 1 at Fri May 31 21:03:00 2024<br>[root@localhost ~]# at -l        <span class="hljs-comment"># 查看任务</span><br>1       Fri May 31 21:03:00 2024 a root<br><br><span class="hljs-comment">#通过文件指定任务</span><br>[root@localhost ~]# vim at.jobs<br>useradd testuser<br>[root@localhost ~]# at -l<br>[root@localhost ~]# at now +5min -f at.jobs<br>job 2 at Fri May 31 21:03:00 2024<br>[root@localhost ~]# at -l<br>2       Fri May 31 21:03:00 2024 a root<br></code></pre></td></tr></table></figure><h2 id="循环调度执行cron"><a href="#循环调度执行cron" class="headerlink" title="循环调度执行cron"></a>循环调度执行cron</h2><p>计划任务（Cron）是一种强大的工具，可以自动执行预定的任务。它非常适合定期运行脚本、备份数据、清理临时文件等一系列重复性任务。</p><p>crontab：是cron服务提供的管理工具</p><p>cron计划任务主要分为用户的任务和系统任务，用户任务是又具体某个用户编写的任务，而系统任务则在系统启动时始终生效</p><h3 id="cron的基本语法"><a href="#cron的基本语法" class="headerlink" title="cron的基本语法"></a>cron的基本语法</h3><p>cron命令的基本语法如下：<br>crontab [-l | -r | -e | -n | -m]</p><h4 id="选项：-1"><a href="#选项：-1" class="headerlink" title="选项："></a>选项：</h4><ul><li>-l：列出当前用户的定时任务。</li><li>-r：删除当前用户的定时任务。</li><li>-e：编辑当前用户的定时任务。</li><li>-n：检查定时任务是否可用。</li><li>-m：发送类似于电子邮件的消息，用于通知定时任务执行的结果。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# crontab -l        <span class="hljs-comment"># 列出当前用户所有计划任务</span><br>[root@localhost ~]# crontab -r        <span class="hljs-comment"># 删除当前用户计划任务</span><br>[root@localhost ~]# crontab -e        <span class="hljs-comment"># 编辑当前用户计划任务</span><br>管理员可以使用 -u username,去管理其他用户的计划任务<br>[root@localhost ~]# vi /etc/cron.deny    <span class="hljs-comment"># 这个文件中加入的用户名无法使用cron</span><br></code></pre></td></tr></table></figure><h4 id="cron任务的配置"><a href="#cron任务的配置" class="headerlink" title="cron任务的配置"></a>cron任务的配置</h4><p>每个用户可以通过crontab命令来编辑自己的任务计划。要编辑cron任务，可以使用crontab -e命令。</p><h4 id="编辑cron任务"><a href="#编辑cron任务" class="headerlink" title="编辑cron任务"></a>编辑cron任务</h4><p>要编辑cron任务计划，可以使用以下命令打开cron编辑器：<br>crontab -e</p><h4 id="配置cron任务的格式"><a href="#配置cron任务的格式" class="headerlink" title="配置cron任务的格式"></a>配置cron任务的格式</h4><p>cron任务的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">分 时 日 月 星期 命令<br>* 表示任何数字都符合<br>0 2 * * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每天的2点</span><br>0 2 14 * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每月14号2点</span><br>0 2 14 2 * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每年2月14号2点</span><br>0 2 * * 5 <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每个星期5的2点</span><br>0 2 * 6 5 <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每年6月份的星期5的2点</span><br>0 2 2 * 5 <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每月2号或者星期5的2点   星期和日同时存在，那么就是或的关系</span><br>0 2 2 6 5 <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每年6月2号或者星期5的2点</span><br><br>*/5 * * * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt    <span class="hljs-comment"># 每隔5分钟执行一次</span><br>0 2 1,4,6 * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt    <span class="hljs-comment"># 每月1号，4号，6号的2点</span><br>0 2 5-9 * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每月5-9号的2点</span><br><br>* * * * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每分钟</span><br>0 * * * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每整点</span><br>* * 2 * * <span class="hljs-built_in">date</span> &gt;&gt; date.txt        <span class="hljs-comment"># 每月2号的每分钟</span><br></code></pre></td></tr></table></figure><p>其中，第一个字段表示分钟（0-59），第二个字段表示小时（0-23），第三个字段表示天（1-31），第四个字段表示月份（1-12），第五个字段表示星期（0-7）。第六个字段是要执行的命令或脚本。</p><p>例如，要每天上午10点重启系统，可以配置如下：0 10 * * * reboot</p><p>在线crontab测试网站： <a href="https://crontab.guru/#0">https://crontab.guru/#0</a><em>*</em><em>_</em>_*</p><h4 id="查看任务存放位置"><a href="#查看任务存放位置" class="headerlink" title="查看任务存放位置"></a>查看任务存放位置</h4><p>[root@localhost ~]# cat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p><ul><li><ul><li><ul><li><ul><li><ul><li>date &gt;&gt; file.txt</li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>这里列举几个常见的cron任务的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#每天凌晨3点备份文件：</span><br>0 3 * * * /path/to/backup.sh<br><br><span class="hljs-comment">#每周一上午8点清理临时文件：</span><br>0 8 * * 1 /path/to/cleanup.sh<br><br><span class="hljs-comment">#每隔10分钟检查服务器状态：</span><br>*/10 * * * * /path/to/check_status.sh<br></code></pre></td></tr></table></figure><h3 id="cron系统任务"><a href="#cron系统任务" class="headerlink" title="cron系统任务"></a>cron系统任务</h3><ul><li>临时文件的清理&#x2F;tmp &#x2F;var&#x2F;tmp</li><li>系统信息的采集 sar</li><li>日志的轮转(切割) lgrotate</li><li>通常不是由用户定义</li><li>文件的位置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# vim /etc/crontab    <span class="hljs-comment"># 默认没有定义任何计划任务</span><br>[root@localhost ~]# <span class="hljs-built_in">ls</span> /etc/cron.d        <span class="hljs-comment"># 定义的计划任务每个小时会执行</span><br>0hourly  sysstat<br>[root@localhost ~]# <span class="hljs-built_in">cat</span> /etc/cron.d/0hourly <br><span class="hljs-comment"># Run the hourly jobs</span><br>SHELL=/bin/bash<br>PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>MAILTO=root<br>01 * * * * root run-parts /etc/cron.hourly        <span class="hljs-comment"># 每小时01分以root身份执行/etc/cron.hourly/目录下的所有脚本</span><br></code></pre></td></tr></table></figure><ul><li>crond仅仅会执行每小时定义的脚本 &#x2F;etc&#x2F;cron.hourly</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">ls</span> /etc/cron.hourly/<br>[root@localhost ~]# <span class="hljs-built_in">cat</span> /etc/cron.hourly/0anacron<br>/usr/sbin/anacron -s        <span class="hljs-comment"># anacron是用来检查是否有错过的计划任务需要被执行</span><br>[root@localhost ~]# vi /etc/anacrontab<br>1 5 cron.daily <span class="hljs-built_in">nice</span> run-parts /etc/cron.daily<br><span class="hljs-comment">#每天开机 5 分钟后就检查 /etc/cron.daily 目录内的文件是否被执行，如果今天没有被执行，那就执行</span><br>7 25 cron.weekly <span class="hljs-built_in">nice</span> run-parts /etc/cron.weekly<br><span class="hljs-comment">#每隔 7 天开机后 25 分钟检查 /etc/cron.weekly 目录内的文件是否被执行，如果一周内没有被执行，就会执行</span><br>©monthly 45 cron.monthly <span class="hljs-built_in">nice</span> run-parts /etc/cron.monthly<br><span class="hljs-comment">#每隔一个月开机后 45 分钟检查 /etc/cron.monthly 目录内的文件是否被执行，如果一个月内没有被执行，那就执行</span><br></code></pre></td></tr></table></figure><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><p>Linux系统和许多程序会产生各种错误信息、告警信息和其他的提示信息，这些各种信息都应该记录到日志文件中。Linux系统日志对管理员来说，是了解系统运行的主要途径，因此需要对Linux日志系统有详细的了解。</p><h2 id="常见的日志文件"><a href="#常见的日志文件" class="headerlink" title="常见的日志文件"></a>常见的日志文件</h2><table><thead><tr><th>日志文件</th><th>解释</th></tr></thead><tbody><tr><td>&#x2F;var&#x2F;log&#x2F;messages</td><td>系统主日志文件</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;secure</td><td>记录认证、安全的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;maillog</td><td>跟邮件postfix相关</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;cron</td><td>crond、at进程产生的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;dmesg</td><td>记录系统启动时加载的硬件相关信息日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;yum.log</td><td>yum的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;mysqld.log</td><td>MySQL日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;xferlog</td><td>和访问FTP服务器相关</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;boot.log</td><td>系统启动过程日志记录存放</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;wtmp</td><td>当前登录的用户(可以直接在命令行输入w查看)</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;lastlog</td><td>所有用户的登录情况(可以直接在命令行输入lastlog查看)</td></tr></tbody></table><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>有多种方法可以查看日志，可以通过cat、tail等命令来查看<br>但是往往日志文件中内容都是非常多的，所以对于初学者通过cat查看不是很直观。这个时候我们可以配合一些其他过滤工具来过滤日志里面的内容。如：grep，awk等等。</p><h2 id="日志系统-rsyslogd"><a href="#日志系统-rsyslogd" class="headerlink" title="日志系统-rsyslogd"></a>日志系统-rsyslogd</h2><h3 id="处理日志的进程"><a href="#处理日志的进程" class="headerlink" title="处理日志的进程"></a>处理日志的进程</h3><p>rsyslogd：绝大部分日志记录，和系统操作有关，安全，认证sshd,su，计划任务at,cron</p><p>httpd&#x2F;nginx&#x2F;mysql等等应用可以以自己的方式记录日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ps aux |grep rsyslogd<br>root       6808  0.0  0.2 216408  5016 ?        Ssl  09:32   0:00 /usr/sbin/rsyslogd -n<br>root       7724  0.0  0.0 112724   988 pts/0    S+   10:39   0:00 grep --color=auto rsyslogd<br></code></pre></td></tr></table></figure><p>日志可以存放在本地<br>日志可以存放在远程服务器</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# rpm -qc rsyslog<br>/etc/logrotate.d/syslog        <span class="hljs-comment"># 日志轮转(切割)相关</span><br>/etc/rsyslog.conf            <span class="hljs-comment"># rsyslogd的主配置文件</span><br>/etc/sysconfig/rsyslog        <span class="hljs-comment"># rsyslogd相关文件</span><br>[root@localhost ~]# vim /etc/rsyslog.conf<br><span class="hljs-comment"># 告诉rsyslogd进程 哪个设备(facility)，关于哪个级别的信息，以及如何处理</span><br>authpriv.*                       /var/log/secure<br>mail.*                           /var/log/maillog<br>cron.*                           /var/log/cron<br>*.emerg                          :omusrmsg:*<br>authpriv.*                       *                    <span class="hljs-comment"># 所有终端</span><br>authpriv.*                       @192.168.1.123        <span class="hljs-comment"># UDP</span><br>authpriv.*                       @@192.168.1.123        <span class="hljs-comment"># TCP</span><br></code></pre></td></tr></table></figure><h3 id="日志类型-facility"><a href="#日志类型-facility" class="headerlink" title="日志类型(facility)"></a>日志类型(facility)</h3><table><thead><tr><th>序号</th><th>Facility</th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>kern(kernel)</td><td>Linux内核产生的信息，大部分是硬件检测和内核功能的启用</td></tr><tr><td>1</td><td>user</td><td>用户层级产生的信息</td></tr><tr><td>2</td><td>mail</td><td>所有邮件收发的相关信息</td></tr><tr><td>3</td><td>daemon</td><td>系统服务产生的信息</td></tr><tr><td>4</td><td>auth</td><td>与认证、授权相关的信息，如login、ssh、su等产生的信息</td></tr><tr><td>5</td><td>syslog</td><td>syslogd服务产生的信息</td></tr><tr><td>6</td><td>lpr</td><td>打印相关的信息</td></tr><tr><td>7</td><td>news</td><td>新闻群组相关的信息</td></tr><tr><td>8</td><td>uucp</td><td>Unix to Unix Copy Protocol 早期Unix系统间的数据交换协议</td></tr><tr><td>9</td><td>cron</td><td>周期性计划任务程序，如cron、at等产生的信息</td></tr><tr><td>10</td><td>authpriv</td><td>与auth类似，但记录的多为帐号相关的信息，如pam模块的调用等</td></tr><tr><td>16~23</td><td>local0~local7</td><td>保留给本地用户使用的日志类型，通常与终端交互相关</td></tr></tbody></table><p>日志级别</p><table><thead><tr><th>级别(日志重要级别)</th><th>解释</th></tr></thead><tbody><tr><td>LOG_EMERG</td><td>紧急，致命，服务无法继续运行，如配置文件丢失</td></tr><tr><td>LOG_ALERT</td><td>报警，需要立即处理，如磁盘空间使用95%</td></tr><tr><td>LOG_CRIT</td><td>致命行为</td></tr><tr><td>LOG_ERR(error)</td><td>错误行为</td></tr><tr><td>LOG_WARNING</td><td>警告信息</td></tr><tr><td>LOG_NOTICE</td><td>普通</td></tr><tr><td>LOG_INFO</td><td>标准信息</td></tr><tr><td>LOG_DEBUG</td><td>调试信息，排错才开，一般不建议使用</td></tr></tbody></table><h2 id="日志文件归档"><a href="#日志文件归档" class="headerlink" title="日志文件归档"></a>日志文件归档</h2><p>如果我们不管理系统产生的上述各种日志文件，那么久而久之日志就会变成“屎山”。日志文件及内容越堆越多，不仅难以查阅，还会因为单一文件过大而影响新的内容写入的效率<br>logrotate就是一个不错的日志处理程序，准确的说是对日志进行“归档”之类的工作</p><h2 id="logrotate-日志轮转"><a href="#logrotate-日志轮转" class="headerlink" title="logrotate(日志轮转)"></a>logrotate(日志轮转)</h2><p>如果没有日志轮转，日志文件会越来越大<br>将丢弃系统中最旧的日志文件，以节省空间<br>事实上logrotate是挂在cron配置目录cron.daily下面的，所以会被cron每天执行一次：</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LVM逻辑卷管理器</title>
    <link href="/2025/10/25/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <url>/2025/10/25/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="LVM（逻辑卷管理器）"><a href="#LVM（逻辑卷管理器）" class="headerlink" title="LVM（逻辑卷管理器）"></a>LVM（逻辑卷管理器）</h1><p>逻<br>辑卷管理器是Linux系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。尽管对传统的硬盘分区进行强制扩容或缩容从理论上来讲是可行的，但是却可能造成数据的丢失。而LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整。</p><p>物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列，这都可以。卷组建立在物理卷之上，一个卷组可以包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。</p><p>PE(物理卷)最小存储单元，VG（卷组）通过PV组合好PE，成一个整的；然后LV（逻辑卷）从VG分出来可供挂载使用</p><h2 id="部署逻辑卷"><a href="#部署逻辑卷" class="headerlink" title="部署逻辑卷"></a>部署逻辑卷</h2><p>常用的LVM部署命令</p><table><thead><tr><th>功能&#x2F;命令</th><th>物理卷管理</th><th>卷组管理</th><th>逻辑卷管理</th></tr></thead><tbody><tr><td>扫描</td><td>pvscan</td><td>vgscan</td><td>lvscan</td></tr><tr><td>建立</td><td>pvcreate</td><td>vgcreate</td><td>lvcreate</td></tr><tr><td>显示</td><td>pvdisplay</td><td>vgdisplay</td><td>lvdisplay</td></tr><tr><td>删除</td><td>pvremove</td><td>vgremove</td><td>lvremove</td></tr><tr><td>扩展</td><td></td><td>vgextend</td><td>lvextend</td></tr><tr><td>缩小</td><td></td><td>vgreduce</td><td>lvreduce</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#第1步：让新添加的两块硬盘设备支持LVM技术</span><br>[root@localhost ~]# pvcreate /dev/nvme0n2 /dev/nvme0n3<br><span class="hljs-comment">#有时候创建不成功，有残留数据需要重新做分区表</span><br><span class="hljs-comment">#[root@localhost ~]#parted /dev/sd[b-c] mklabel msdos</span><br><br><span class="hljs-comment">#第2步：把两块硬盘设备加入到storage卷组中，然后查看卷组的状态</span><br>[root@localhost ~]# vgcreate storage /dev/nvme0n2 /dev/nvme0n3<br>  Volume group <span class="hljs-string">&quot;storage&quot;</span> successfully created<br>[root@localhost ~]# vgdisplay storage<br><br><span class="hljs-comment">#第3步：切割出一个约为150MB的逻辑卷设备。</span><br><span class="hljs-comment">#这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位:第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷;另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。</span><br><span class="hljs-comment"># [root@localhost ~]# lvcreate -n vo -l 37 -I 8M storage</span><br>[root@localhost ~]# lvcreate -n vo -l 37 storage<br>  Logical volume <span class="hljs-string">&quot;vo&quot;</span> created.<br><span class="hljs-comment"># 每个PE占4M，37*4=148M，远少于/dev/nvme0n2的5G，不会占用到第二个PV（/dev/nvme0n3），所以lsblk只看到占用了/dev/nvme0n2</span><br><br>[root@localhost ~]# lsblk<br>[root@localhost ~]# lvdisplay<br><br><span class="hljs-comment">#第4步：把生成好的逻辑卷进行格式化，然后挂载使用。</span><br>[root@localhost ~]# mkfs.ext4 /dev/storage/vo<br><br>[root@localhost ~]# <span class="hljs-built_in">mkdir</span> /mnt/vo<br>[root@localhost ~]# mount /dev/storage/vo /mnt/vo<br>[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>Filesystem              Size  Used Avail Use% Mounted on<br>devtmpfs                4.0M     0  4.0M   0% /dev<br>tmpfs                   872M     0  872M   0% /dev/shm<br>tmpfs                   349M  5.2M  344M   2% /run<br>/dev/mapper/rl-root      17G  1.7G   16G  10% /<br>/dev/nvme0n1p1          960M  261M  700M  28% /boot<br>tmpfs                   175M     0  175M   0% /run/user/0<br>/dev/mapper/storage-vo  134M   14K  123M   1% /mnt/vo<br>[root@localhost ~]# lsblk<br>NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS<br>sr0           11:0    1  1.7G  0 rom<br>nvme0n1      259:0    0   20G  0 disk<br>├─nvme0n1p1  259:1    0    1G  0 part /boot<br>└─nvme0n1p2  259:2    0   19G  0 part<br>  ├─rl-root  253:0    0   17G  0 lvm  /<br>  └─rl-swap  253:1    0    2G  0 lvm  [SWAP]<br>nvme0n2      259:3    0    5G  0 disk<br>└─storage-vo 253:2    0  148M  0 lvm  /mnt/vo<br>nvme0n3      259:4    0    5G  0 disk<br>nvme0n4      259:5    0    5G  0 disk<br>nvme0n5      259:6    0    5G  0 disk<br>nvme0n6      259:7    0    5G  0 disk<br><br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/dev/storage/vo /mnt/vo ext4 defaults 0 0&quot;</span> &gt;&gt; /etc/fstab<br></code></pre></td></tr></table></figure><h2 id="扩容逻辑卷"><a href="#扩容逻辑卷" class="headerlink" title="扩容逻辑卷"></a>扩容逻辑卷</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#第1步：把上一个实验中的逻辑卷vo扩展至290MB</span><br>[root@localhost ~]# umount /mnt/vo<br>[root@localhost ~]# lvextend -L 290M /dev/storage/vo<br><br><span class="hljs-comment">#第2步：检查硬盘完整性，并重置硬盘容量，否则挂载了还是148M</span><br>[root@localhost ~]# e2fsck -f /dev/storage/vo<br>[root@localhost ~]# resize2fs /dev/storage/vo<br><br><span class="hljs-comment">#第3步：重新挂载硬盘设备并查看挂载状态</span><br>[root@localhost ~]# systemctl daemon-reload<br>[root@localhost ~]# mount -a<br>[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>Filesystem              Size  Used Avail Use% Mounted on<br>devtmpfs                4.0M     0  4.0M   0% /dev<br>tmpfs                   872M     0  872M   0% /dev/shm<br>tmpfs                   349M  5.2M  344M   2% /run<br>/dev/mapper/rl-root      17G  1.7G   16G  10% /<br>/dev/nvme0n1p1          960M  261M  700M  28% /boot<br>tmpfs                   175M     0  175M   0% /run/user/0<br>/dev/mapper/storage-vo  268M   14K  250M   1% /mnt/vo<br><br><span class="hljs-comment">#第4步，如果扩容到6G，则会占用到nvme0n3的pv</span><br>[root@localhost ~]# umount /mnt/vo<br>[root@localhost ~]# lvextend -L 6G /dev/storage/vo<br>[root@localhost ~]# e2fsck -f /dev/storage/vo<br>[root@localhost ~]# resize2fs /dev/storage/vo<br>[root@localhost ~]# mount -a<br>[root@localhost ~]# lsblk<br>NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS<br>sr0           11:0    1  1.7G  0 rom<br>nvme0n1      259:0    0   20G  0 disk<br>├─nvme0n1p1  259:1    0    1G  0 part /boot<br>└─nvme0n1p2  259:2    0   19G  0 part<br>  ├─rl-root  253:0    0   17G  0 lvm  /<br>  └─rl-swap  253:1    0    2G  0 lvm  [SWAP]<br>nvme0n2      259:3    0    5G  0 disk<br>└─storage-vo 253:2    0    6G  0 lvm  /mnt/vo<br>nvme0n3      259:4    0    5G  0 disk<br>└─storage-vo 253:2    0    6G  0 lvm  /mnt/vo<br>nvme0n4      259:5    0    5G  0 disk<br>nvme0n5      259:6    0    5G  0 disk<br>nvme0n6      259:7    0    5G  0 disk<br>[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>Filesystem              Size  Used Avail Use% Mounted on<br>devtmpfs                4.0M     0  4.0M   0% /dev<br>tmpfs                   872M     0  872M   0% /dev/shm<br>tmpfs                   349M  5.2M  344M   2% /run<br>/dev/mapper/rl-root      17G  1.7G   16G  10% /<br>/dev/nvme0n1p1          960M  261M  700M  28% /boot<br>tmpfs                   175M     0  175M   0% /run/user/0<br>/dev/mapper/storage-vo  5.7G   14K  5.4G   1% /mnt/vo<br></code></pre></td></tr></table></figure><h2 id="缩小逻辑卷"><a href="#缩小逻辑卷" class="headerlink" title="缩小逻辑卷"></a>缩小逻辑卷</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#第1步：检查文件系统的完整性</span><br>[root@localhost ~]# umount /mnt/vo<br>[root@localhost ~]# e2fsck -f /dev/storage/vo<br><br><span class="hljs-comment">#第2步：把逻辑卷vo的容量减小到120MB</span><br>[root@localhost ~]# resize2fs /dev/storage/vo 120M<br>[root@localhost ~]# lvreduce -L 120M /dev/storage/vo<br><br><span class="hljs-comment">#第3步：重新挂载文件系统并查看系统状态</span><br>[root@localhost ~]# mount -a<br>[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>Filesystem              Size  Used Avail Use% Mounted on<br>devtmpfs                4.0M     0  4.0M   0% /dev<br>tmpfs                   872M     0  872M   0% /dev/shm<br>tmpfs                   349M  5.2M  344M   2% /run<br>/dev/mapper/rl-root      17G  1.7G   16G  10% /<br>/dev/nvme0n1p1          960M  261M  700M  28% /boot<br>tmpfs                   175M     0  175M   0% /run/user/0<br>/dev/mapper/storage-vo  108M   14K   99M   1% /mnt/vo<br></code></pre></td></tr></table></figure><h2 id="逻辑卷快照"><a href="#逻辑卷快照" class="headerlink" title="逻辑卷快照"></a>逻辑卷快照</h2><p>LVM还具备有“快照卷”功能，该功能类似于虚拟机软件的还原时间点功能。例如，可以对某一个逻辑卷设备做一次快照，如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：</p><ul><li>快照卷的容量必须等同于逻辑卷的容量；</li><li>快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#接下来用重定向往逻辑卷设备所挂载的目录中写入一个文件</span><br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span> &gt; /mnt/vo/readme.txt<br>[root@localhost ~]# <span class="hljs-built_in">ls</span> -l /mnt/vo<br>total 14<br>drwx------. 2 root root 12288 Apr 18 13:38 lost+found<br>-rw-r--r--. 1 root root    12 Apr 18 13:48 readme.txt<br><span class="hljs-comment">#第1步：使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。强烈建议快照大小和原来的LVM一样大</span><br>[root@localhost ~]# lvcreate -L 120M -s -n SNAP /dev/storage/vo<br><br><span class="hljs-comment">#强烈建议快照大小和原来的LVM一样大，虽然指定大小是120M，并不是创建一个120M大小的快照，除非修改、新增的文件超出120M才会出事情，删除不影响。</span><br>  Logical volume <span class="hljs-string">&quot;SNAP&quot;</span> created.<br><br><span class="hljs-comment">#第2步：在逻辑卷所挂载的目录中创建一个50MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间占的用量上升了</span><br>[root@localhost ~]# <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/mnt/vo/<br><br><span class="hljs-comment">#第3步：为了校验SNAP快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载。</span><br>[root@localhost ~]# umount /mnt/vo<br>[root@localhost ~]# lvconvert --merge /dev/storage/SNAP <br><br><span class="hljs-comment">#第4步：快照卷会被自动删除掉，并且刚刚在逻辑卷设备被执行快照操作后再创建出来的50MB的垃圾文件也被清除了</span><br>[root@localhost ~]# mount -a<br>[root@localhost ~]# <span class="hljs-built_in">ls</span> /mnt/vo/<br>lost+found  readme.txt<br></code></pre></td></tr></table></figure><h2 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#第1步：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。</span><br>[root@localhost ~]# umount /mnt/vo/<br>[root@localhost ~]# vi /etc/fstab <br><span class="hljs-comment">#</span><br><span class="hljs-comment"># /etc/fstab</span><br><span class="hljs-comment"># Created by anaconda on Mon Apr 15 17:31:00 2019</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span><br><span class="hljs-comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span><br><span class="hljs-comment">#</span><br>/dev/mapper/centos-root /                       xfs     defaults        0 0<br>UUID=63e91158-e754-41c3-b35d-7b9698e71355 /boot                   xfs     defaults        0 0<br>/dev/mapper/centos-swap swap                    swap    defaults        0 0<br><br><span class="hljs-comment">#第2步：删除逻辑卷设备，需要输入y来确认操作</span><br>[root@localhost ~]# lvremove /dev/storage/vo <br>Do you really want to remove active logical volume storage/vo? [y/n]: y<br>  Logical volume <span class="hljs-string">&quot;vo&quot;</span> successfully removed<br><br><span class="hljs-comment">#第3步：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。</span><br>[root@localhost ~]# vgremove storage<br>  Volume group <span class="hljs-string">&quot;storage&quot;</span> successfully removed<br><br><span class="hljs-comment">#第4步：删除物理卷设备</span><br>[root@localhost ~]# pvremove /dev/nvme0n2 /dev/nvme0n3<br>  Labels on physical volume <span class="hljs-string">&quot;/dev/nvme0n2&quot;</span> successfully wiped.<br>  Labels on physical volume <span class="hljs-string">&quot;/dev/nvme0n3&quot;</span> successfully wiped.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络管理</title>
    <link href="/2025/10/25/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    <url>/2025/10/25/Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h1><p>数据从产生到传递到目的地的过程中会经历好几个过程，每个过程都负责加工自己这部分的内容，类似于工厂流水线<br>目前我们只需要有个最基本的概念：</p><ul><li>IP地址是用来标识网络中位置的，比如你在江苏省xxx市xxx路xxx号</li><li>MAC地址是每个网络设备的唯一ID，比如你的身份证号码</li><li>如果想要发送数据，必须(暂且认为必须)同时拥有IP和MAC地址</li><li>Linux的网络管理基础部分就是需要大家掌握IP地址的配置</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ul><li><p>在IP网络中，通信节点需要有一个唯一的IP地址</p></li><li><p>IP地址用于IP报文的寻址以及标识一个节点</p></li><li><p>IPv4地址一共32bits，使用点分十进制的形式表示 </p></li><li><p>IPv4地址由网络位和主机位组成<br>– 网络位一致表示在同一个广播域中，可以直接通信<br>– 主机位用于在同一个局域网中标识唯一节点</p></li></ul><p>早期参与互联网的设备不多，所以仅仅使用ABC类地址分配给用户即可<br>随着网络用户的增多，ABC类分配地址过于浪费，于是出现子网掩码方式划分网络位和主机位</p><h2 id="IP网络通信类型"><a href="#IP网络通信类型" class="headerlink" title="IP网络通信类型"></a>IP网络通信类型</h2><p>单播(Unicast)<br>广播(Broadcast)<br>组播(Multicast)</p><h2 id="子网掩码-Netmask"><a href="#子网掩码-Netmask" class="headerlink" title="子网掩码(Netmask)"></a>子网掩码(Netmask)</h2><p>网络掩码与IP地址搭配使用，用于描述一个IP地址中的网络部分及主机部分<br>网络掩码32bits，与32bits的IP地址一一对应，掩码中为1的位对应IP地址中的网络位，掩码中为0的位对应IP地址中的主机位<br>减少一个局域网中的设备数量可以有效降低广播报文消耗资源<br>可变长子网掩码可以将一个局域网中的主机地址分配的更加小</p><h2 id="广播地址与网络号"><a href="#广播地址与网络号" class="headerlink" title="广播地址与网络号"></a>广播地址与网络号</h2><ul><li>在局域网中经常会有广播的需要(比如，mac地址查询，地址冲突检测等等)，所以将主机位全为1的地址做为本局域网的广播地址(注意！广播并不能跨越不同的局域网)</li><li>在网络中需要表示整个局域网，就像邮政编码表示一个大的区域一样，所以将主机位全为0的地址作为本局域网的网络号，用来代指整个网段</li></ul><h2 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h2><p>如果要取得互联网合法地址用于通信，必须要找iana.org组织分配<br>很多企业内部都有大量的网络设备，大多数时候这些设备只需要内部通信即可<br>私有IP地址空间中的地址不需要申请，随意使用，但是不能在互联网上与合法地址通信(因为对方没法回复你这个地址，因为世界上私有IP地址段无数个重复的，怎么知道回到谁那里呢)<br>而我们明明用的私有IP地址，也可以上网，因为我们需要先把自己的上网请求提交给网络中的网关(就是你家的出口路由器)，再由网关代替我们去获取内容转交给我们的电脑手机，而网关往往能从运营商那里得到一个合法的公有IP地址</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>DHCP（动态主机配置协议），主要用于给设备自动的分配IP地址以及网络信息，以便网络设备能够连接到网络并进行通信</p><p>DHCP给设备提供的信息如下：</p><ul><li>IP地址</li><li>子网掩码</li><li>网关地址</li><li>DNS服务器地址</li><li>租约时间</li></ul><h2 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h2><ul><li>客户端启动时发送 DHCP 发现(DHCPDISCOVER)广播消息,寻找 DHCP 服务器。</li><li>DHCP 服务器收到广播消息后,会提供一个未被使用的 IP 地址以及其他网络配置信息(如子网掩码、默认网关、DNS 服务器等),并发送 DHCP 提供(DHCPOFFER)消息给客户端。</li><li>客户端收到一个或多个 DHCP 提供消息后,会选择其中一个 DHCP 服务器提供的 IP 地址,并发送 DHCP 请求(DHCPREQUEST)消息确认。</li><li>DHCP 服务器收到客户端的 DHCP 请求消息后,会将该 IP 地址分配给客户端,并发送 DHCP 确认(DHCPACK)消息给客户端。</li><li>客户端收到 DHCP 确认消息后,就可以使用分配到的 IP 地址和其他网络配置参数连接到网络了。<br>dhclient<br>我们可以通过抓包软件，捕捉到主机通过DHCP方式获取ip的过程，一共有4个数据包：<br>其中每个数据包的作用如下：</li><li>Discover消息是用于客户端向整个内网发送广播，期待DHCP服务器进行回应<br>– 这个数据包中的重要内容就是：消息类型，客户端ID，主机名，请求获得的信息</li><li>Offer消息是DHCP服务器对客户的回应<br>– 这个消息中会回复对方所需要的所有信息</li><li>Request这个是客户端确认DHCP服务器的消息<br>– 这个消息和第一个消息差不多，但是消息类别变为Request，并且会携带请求的IP地址</li><li>ACKDHCP服务器给客户端的最终确认<br>– 这个消息和第二个消息差不多，但是消息类型变为ACK</li></ul><h1 id="DNS（域名解析）"><a href="#DNS（域名解析）" class="headerlink" title="DNS（域名解析）"></a>DNS（域名解析）</h1><p>DNS(Domain Name System) 是一套从域名到IP的映射的协议<br>在网络世界中，如果我们想要给某个机器，或者是某个网站去发送一个数据，都需要通过IP地址来找到对方，比如我们想要使用百度来搜索东西，就需要知道百度的IP地址，换句话说只要知道了百度的IP地址，我们就可以访问到百度<br>但是IP地址不易记忆，不可能记住每一个网站的IP地址是什么，于是早期的搞IT的那帮人研发出一个叫做主机名的东西。<br>最开始人们把IP和主机名的的对应关系记录在本地，这个文件目前在windows系统的C:\Windows\System32\drivers\etc\hosts中。但是后面发现并不好用，而且需要经常手动更新这个文件。<br>随着主机名越来越多，hosts文件不易维护，所以后来改用域名解析系统DNS：</p><ul><li>一个组织的系统管理机构，维护系统内的每个主机的IP和主机名的对应关系</li><li>如果新计算机接入网络，将这个信息注册到数据库中</li><li>用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库, 得到对应的IP地址。</li></ul><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>主域名是用来识别主机名称和主机所属的组织机构的一种分层结构的名称。 例如：<a href="http://www.baidu.com(域名使用.连接)/">http://www.baidu.com(域名使用.连接)</a></p><ul><li>com： 一级域名，表示这是一个企业域名。同级的还有 “net”(网络提供商)，”org”(非盈利组织) 等。</li><li>baidu: 二级域名, 公司名。</li><li>www: 只是一种习惯用法，并不是每个域名都支持。</li><li>http:&#x2F;&#x2F; : 要使用什么协议来连接这个主机名。</li></ul><h2 id="常见的域名解析服务器"><a href="#常见的域名解析服务器" class="headerlink" title="常见的域名解析服务器"></a>常见的域名解析服务器</h2><ul><li>114dns<br>​– 114.114.114.114<br>– 114.114.115.115<br>这是国内用户量数一数二的 dns 服务器，该 dns 一直标榜高速、稳定、无劫持、防钓鱼。</li><li>Google DNS<br>​– 8.8.8.8<br>– 8.8.4.4<br>​ ……<br>可以理解为由这些服务器帮我们记录的域名和IP的对应关系，我们访问域名的时候去找这些dns服务器询问该域名对应的IP地址，当然，除了上述提到的这些dns服务器，三大运营商也提供了dns解析服务</li></ul><h2 id="域名解析的过程"><a href="#域名解析的过程" class="headerlink" title="域名解析的过程"></a>域名解析的过程</h2><ul><li>浏览器发起域名解析，首先查询浏览器缓存，如果没有，就查询hosts文件，如果没有就提出域名解析请求</li><li>客户机提出域名解析请求，并将该请求发送给本地的域名服务器。</li><li>当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回。</li><li>如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址。</li><li>本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址。</li><li>重复第四步,直到找到正确的纪录。</li><li>本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机</li></ul><h1 id="配置网络服务"><a href="#配置网络服务" class="headerlink" title="配置网络服务"></a>配置网络服务</h1><h2 id="图像化配置网络"><a href="#图像化配置网络" class="headerlink" title="图像化配置网络"></a>图像化配置网络</h2><p>使用nmtui命令来配置网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# nmtui<br><span class="hljs-comment"># 可以将环境变量改成中文</span><br>[root@localhost ~]# yum install -y langpacks-zh_CN        <span class="hljs-comment"># 安装中文包支持</span><br>[root@localhost ~]# <span class="hljs-built_in">export</span> LANG=zh_CN.UTF-8<br><span class="hljs-comment"># 改回英文是LANG=en_US.UTF-8</span><br></code></pre></td></tr></table></figure><h3 id="重新加载网络配置"><a href="#重新加载网络配置" class="headerlink" title="重新加载网络配置"></a>重新加载网络配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# systemctl restart NetworkManager<br><span class="hljs-comment"># 或者先禁用再启用网卡</span><br>[root@localhost ~]# yum install -y NetworkManager-initscripts-updown-1:1.48.10-2.el9_5.noarch<br>[root@localhost ~]# ifdown ens160        <span class="hljs-comment"># 禁用网卡</span><br>[root@localhost ~]# ifup ens160            <span class="hljs-comment"># 启用网卡</span><br></code></pre></td></tr></table></figure><h2 id="命令行配置网络"><a href="#命令行配置网络" class="headerlink" title="命令行配置网络"></a>命令行配置网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改网卡配置文件</span><br>[root@localhost ~]# <span class="hljs-built_in">cat</span> /etc/NetworkManager/system-connections/ens160.nmconnection <br>[connection]<br><span class="hljs-built_in">id</span>=ens160<br>uuid=dfea55d8-6ddc-3229-8152-cb9e261de181<br><span class="hljs-built_in">type</span>=ethernet<br>autoconnect-priority=-999<br>interface-name=ens160<br>timestamp=1732264040<br><br>[ethernet]<br><br>[ipv4]<br>address1=192.168.88.110/24,192.168.88.2<br>dns=114.114.114.114;114.114.115.115;<br>method=manual<br><br>[ipv6]<br>addr-gen-mode=eui64<br>method=auto<br><br>[proxy]<br></code></pre></td></tr></table></figure><p>当修改完Linux系统中的服务配置文件后，并不会对服务程序立即产生效果。要想让服务程序获取到最新的配置文件，需要手动重启相应的服务，之后就可以看到网络畅通了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# systemctl restart NetworkManager<br></code></pre></td></tr></table></figure><h3 id="网卡配置文件参数"><a href="#网卡配置文件参数" class="headerlink" title="网卡配置文件参数"></a>网卡配置文件参数</h3><table><thead><tr><th>节</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>[connection]</td><td>id</td><td>连接的名称，这里是 ens160。</td></tr><tr><td>_</td><td>uuid</td><td>连接的唯一标识符（UUID），用于唯一识别此连接。</td></tr><tr><td></td><td>type</td><td>连接的类型，ethernet 表示这是一个以太网连接。</td></tr><tr><td></td><td>autoconnect-priority</td><td>自动连接优先级，数值越小优先级越低。这里设置为 -999，表示极低的优先级。</td></tr><tr><td></td><td>interface-name</td><td>连接对应的网络接口名称，这里是 ens160。</td></tr><tr><td></td><td>timestamp</td><td>连接的时间戳，表示最后修改的时间。</td></tr><tr><td>[ethernet]</td><td>-</td><td>此节用于配置以太网特定的设置，当前没有额外参数。</td></tr><tr><td>[ipv4]</td><td>address1</td><td>静态 IPv4 地址及其子网掩码，格式为 IP地址&#x2F;子网掩码 和网关，例：192.168.88.110&#x2F;24,192.168.88.2。</td></tr><tr><td></td><td>dns</td><td>DNS 服务器地址，多个地址用分号分隔，这里是 114.114.114.114;114.114.115.115;。</td></tr><tr><td></td><td>method</td><td>IPv4 地址配置方法，这里设置为 manual，表示使用手动配置。</td></tr><tr><td>[ipv6]</td><td>addr-gen-mode</td><td>地址生成模式，eui64 表示使用 EUI-64 地址生成方式。</td></tr><tr><td></td><td>method</td><td>IPv6 地址配置方法，这里设置为 auto，表示自动获取 IPv6 地址。</td></tr><tr><td>[proxy]</td><td>-</td><td>此节用于配置代理设置，当前没有额外参数。</td></tr></tbody></table><h2 id="nmcli-工具详解"><a href="#nmcli-工具详解" class="headerlink" title="nmcli 工具详解"></a>nmcli 工具详解</h2><p>nmcli命令是redhat7或者centos7之后的命令，该命令可以完成网卡上所有的配置工作，并且可以写入 配置文件，永久生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看接口状态</span><br>[root@localhost ~]# nmcli device status<br>DEVICE  TYPE      STATE                   CONNECTION<br>ens160  ethernet  connected               ens160<br>lo      loopback  connected (externally)  lo<br><span class="hljs-comment">#查看链接信息</span><br>[root@localhost ~]# nmcli connection show<br>NAME    UUID                                  TYPE      DEVICE<br>ens160  dfea55d8-6ddc-3229-8152-cb9e261de181  ethernet  ens160<br>lo      529b2eed-2755-4cce-af3c-999beb49882d  loopback  lo<br><span class="hljs-comment">#配置IP等网络信息</span><br>[root@localhost ~]# nmcli con mod <span class="hljs-string">&quot;ens160&quot;</span> ipv4.addresses 192.168.88.140/24 ipv4.gateway 192.168.88.2 ipv4.dns <span class="hljs-string">&quot;8.8.8.8,8.8.4.4&quot;</span> ipv4.method manual<br><span class="hljs-comment">#启动/停止接口</span><br>[root@localhost ~]# nmcli connection down ens160<br>[root@localhost ~]# nmcli connection up ens160<br><span class="hljs-comment">#创建链接</span><br>[root@localhost ~]# nmcli connection add <span class="hljs-built_in">type</span> ethernet ifname ens160 con-name dhcp_ens160<br><span class="hljs-comment"># 激活链接</span><br>[root@localhost ~]# nmcli connection up dhcp_ens160<br><span class="hljs-comment">#删除链接</span><br>[root@localhost ~]# nmcli connection delete dhcp_ens160<br>成功删除连接 <span class="hljs-string">&#x27;dhcp_ens160&#x27;</span>（37adadf4-419d-47f0-a0f6-af849160a4f7）。<br></code></pre></td></tr></table></figure><h1 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h1><p>ifconfig 命令用于显示或设置网络设备。<br>安装：yum install -y net-tools</p><ul><li><p>语法<br>ifconfig [network_interface]<br>   [down|up]<br>   [add <address>]<br>   [del <address>]<br>   [hw <type> <hw_address>]<br>   [io_addr &lt;I&#x2F;O_address&gt;]<br>   [irq <IRQ>]<br>   [media <media_type>]<br>   [mem_start <memory_address>]<br>   [metric <number>]<br>   [mtu <bytes>]<br>   [netmask <netmask>]<br>   [tunnel <address>]<br>   [-broadcast <address>]<br>   [-pointopoint <address>]<br>   [<IP_address>]</p></li><li><p>选项说明<br>– down&#x2F;up: 禁用&#x2F;启用网络接口<br>– add <address>&#x2F;del <address>: 添加或删除 IP 地址<br>– hw <type> <hw_address>: 设置硬件地址 (MAC 地址)<br>– io_addr &lt;I&#x2F;O_address&gt;: 设置 I&#x2F;O 地址<br>– irq <IRQ>: 设置中断请求<br>– media <media_type>: 设置网络媒体类型<br>– mem_start <memory_address>: 设置内存起始地址<br>– metric <number>: 设置路由度量值<br>– mtu <bytes>: 设置 MTU 值<br>– netmask <netmask>: 设置子网掩码<br>– tunnel <address>: 设置隧道地址<br>– -broadcast <address>: 设置广播地址<br>– -pointopoint <address>: 设置点对点地址<br>– <IP_address>: 设置 IP 地址</p></li><li><p>实例</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#显示网络设备信息</span><br>[root@localhost cmatrix-1.2a]# ifconfig<br>ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.88.136  netmask 255.255.255.0  broadcast 192.168.88.255<br>        inet6 fe80::a49c:12c9:1ebd:8fb2  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 00:0c:29:cb:d5:1a  txqueuelen 1000  (Ethernet)<br>        RX packets 122441  bytes 178564616 (170.2 MiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 13762  bytes 1315614 (1.2 MiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br><span class="hljs-comment">#启动关闭指定网卡</span><br>[root@localhost ~]# ifconfig ens33 down<br>[root@localhost ~]# ifconfig ens33 up<br><br><span class="hljs-comment">#配置IP地址</span><br>[root@localhost ~]# ifconfig eth0 192.168.1.56 <br>//给eth0网卡配置IP地址<br>[root@localhost ~]# ifconfig eth0 192.168.1.56 netmask 255.255.255.0 <br>// 给eth0网卡配置IP地址,并加上子掩码<br>[root@localhost ~]# ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255<br>// 给eth0网卡配置IP地址,加上子掩码,加上个广播地址<br><br><span class="hljs-comment">#设置最大传输单元</span><br>[root@localhost ~]# ifconfig eth0 mtu 1500 <br>//设置能通过的最大数据包大小为 1500 bytes<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁盘整列RAID</title>
    <link href="/2025/10/25/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97RAID/"/>
    <url>/2025/10/25/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97RAID/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h1><p>磁盘阵列（RAID，Redundant Array of Independent Disks）是一种将多个物理硬盘组合在一起形成一个逻辑硬盘组的技术。通过 RAID，可以实现数据冗余、性能提升或两者兼具。RAID 在存储系统中广泛使用，尤其是在服务器和大数据存储环境中，用于提升数据可靠性和性能。</p><h2 id="RAID-0（条带化，Striping）"><a href="#RAID-0（条带化，Striping）" class="headerlink" title="RAID 0（条带化，Striping）"></a>RAID 0（条带化，Striping）</h2><ul><li>特点: 将数据分块并在多个磁盘上并行存储，提升读写性能。</li><li>优点: 极大提高了读写速度，因为数据在多个磁盘上并行操作。</li><li>缺点: 没有冗余，任何一个磁盘的损坏都会导致整个 RAID 失效，数据丢失。</li><li>适用场景: 需要高性能、数据安全性需求不高的场景，比如视频编辑、临时数据存储等。</li></ul><h2 id="RAID-1（镜像，Mirroring）"><a href="#RAID-1（镜像，Mirroring）" class="headerlink" title="RAID 1（镜像，Mirroring）"></a>RAID 1（镜像，Mirroring）</h2><ul><li>特点: 将数据完全复制到另一块磁盘上，提供 1:1 的数据冗余。</li><li>优点: 数据安全性高，任何一个磁盘损坏时，数据仍可以从镜像磁盘中恢复。</li><li>缺点: 存储效率较低，实际可用存储空间为所有磁盘容量的一半。</li><li>适用场景: 需要高数据可靠性和快速恢复的场合，比如数据库、操作系统磁盘等。</li></ul><h2 id="RAID-5（带奇偶校验的条带化，Striping-with-Parity）"><a href="#RAID-5（带奇偶校验的条带化，Striping-with-Parity）" class="headerlink" title="RAID 5（带奇偶校验的条带化，Striping with Parity）"></a>RAID 5（带奇偶校验的条带化，Striping with Parity）</h2><ul><li>特点: 将数据和奇偶校验数据分布在所有磁盘上，提供冗余的同时提升性能。</li><li>优点: 提供数据冗余，同时存储效率较高（磁盘数量越多，效率越好），能够在一个磁盘损坏的情况下恢复数据。</li><li>缺点: 写入性能稍差，尤其是在发生设备故障时，重建过程较慢。</li><li>适用场景: 需要兼顾性能和数据冗余的场景，如文件服务器和应用服务器。</li><li>写性能1，读性能\（N-1）<br>RAID5的核心思想是使用奇偶校验信息来提供数据的冗余备份。当其中一个硬盘驱动器发生故障时，剩余的硬盘驱动器可以通过计算奇偶校验信息来恢复丢失的数据。这种方式既提供了数据冗余和容错能力，又降低了整体存储成本。实际存储空间时总盘数-1。</li></ul><h2 id="RAID-10（RAID-1-0，镜像与条带化的组合）"><a href="#RAID-10（RAID-1-0，镜像与条带化的组合）" class="headerlink" title="RAID 10（RAID 1+0，镜像与条带化的组合）"></a>RAID 10（RAID 1+0，镜像与条带化的组合）</h2><ul><li>特点: 将 RAID 1（镜像）和 RAID 0（条带化）结合使用，既提供数据冗余又提升了性能。</li><li>优点: 既有 RAID 0 的高性能，又有 RAID 1 的高安全性。能够快速恢复数据。</li><li>缺点: 存储效率较低，要求至少 4 块磁盘，实际可用空间为所有磁盘容量的一半。</li><li>适用场景: 需要高性能和高冗余的关键应用场景，如数据库、虚拟化环境等。</li><li>读写性能*N（N为RAID0的硬盘数，此例为2），不能同时坏数据块1a与2a</li></ul><h2 id="RAID-01"><a href="#RAID-01" class="headerlink" title="RAID 01"></a>RAID 01</h2><p>将 RAID 1（镜像）和 RAID 0（条带化）结合使用，既提供数据冗余又提升了性能。先构建RAID 1，再构建RAID 0</p><h2 id="硬件磁盘阵列（Hardware-RAID）"><a href="#硬件磁盘阵列（Hardware-RAID）" class="headerlink" title="硬件磁盘阵列（Hardware RAID）"></a>硬件磁盘阵列（Hardware RAID）</h2><ul><li>特点<br>– 专用硬件控制器：硬件 RAID 使用专门的 RAID 控制器卡（RAID Controller），通常是插入主板的 PCIe 扩展卡或者集成在服务器主板上的芯片。该控制器管理磁盘阵列的所有操作并执行 RAID 级别的计算。<br>– 独立于操作系统：硬件 RAID 完全独立于操作系统，RAID 控制器负责所有 RAID 相关操作，操作系统只看到一个逻辑磁盘。<br>– 硬件加速：硬件 RAID 卡通常带有专用处理器（ASIC 或 FPGA）和缓存，用来加速 RAID 操作，提高性能<br>阵列卡</li></ul><h2 id="软件磁盘阵列（Software-RAID）"><a href="#软件磁盘阵列（Software-RAID）" class="headerlink" title="软件磁盘阵列（Software RAID）"></a>软件磁盘阵列（Software RAID）</h2><ul><li>特点<br>– 由操作系统实现：软件 RAID 通过操作系统内核或专门的 RAID 软件来管理和实现 RAID 功能。Linux 的 mdadm、Windows 的动态磁盘管理和 macOS 的磁盘工具等都支持软件 RAID。<br>– 没有专用硬件：软件 RAID 不需要专用的 RAID 控制器，所有 RAID 计算和管理工作都由主机的 CPU 执行。<br>– 灵活性高：软件 RAID 通常可以在不同的硬件平台之间迁移，因为 RAID 配置数据存储在磁盘上，而不是特定的控制器中。</li></ul><h2 id="硬件-RAID-和软件-RAID-的对比"><a href="#硬件-RAID-和软件-RAID-的对比" class="headerlink" title="硬件 RAID 和软件 RAID 的对比"></a>硬件 RAID 和软件 RAID 的对比</h2><table><thead><tr><th>对比项</th><th>硬件 RAID</th><th>软件 RAID</th></tr></thead><tbody><tr><td>实现方式</td><td>专用 RAID 控制器</td><td>操作系统或软件实现</td></tr><tr><td>性能</td><td>高，特别是在 RAID 5&#x2F;6 等级别中</td><td>较低，占用主机 CPU 资源</td></tr><tr><td>磁盘管理</td><td>独立于操作系统，系统只看到一个逻辑磁盘</td><td>依赖于操作系统的磁盘管理</td></tr><tr><td>成本</td><td>高，需购买 RAID 控制器</td><td>低，无需额外硬件</td></tr><tr><td>功能支持</td><td>支持热备盘、硬盘监控、电池缓存等高级功能</td><td>功能较少，依赖操作系统提供的功能</td></tr><tr><td>灵活性依赖特定硬件，不易迁移</td><td>容易迁移，跨硬件平台使用</td><td></td></tr><tr><td>故障恢复</td><td>控制器损坏可能需要相同型号的控制器</td><td>可以在不同硬件上恢复</td></tr><tr><td>适用场景</td><td>企业级、大型存储系统，数据中心</td><td>个人用户、小型服务器，开发测试环境</td></tr></tbody></table><h1 id="部署磁盘阵列"><a href="#部署磁盘阵列" class="headerlink" title="部署磁盘阵列"></a>部署磁盘阵列</h1><h2 id="mdadm磁盘整列"><a href="#mdadm磁盘整列" class="headerlink" title="mdadm磁盘整列"></a>mdadm磁盘整列</h2><p>对于Linux上通过软件的形式构建磁盘整列，我们常用的方式是通过mdadm这个工具来完成。当然对于部分Linux发行版本，mdadm可能没有内置安装好，所以我们需要手动安装一下。</p><h2 id="安装mdadm工具"><a href="#安装mdadm工具" class="headerlink" title="安装mdadm工具"></a>安装mdadm工具</h2><p>[root@localhost ~]# yum -y install mdadm</p><ul><li>mdadm命令常用参数以及作用<table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>检测设备名称</td></tr><tr><td>-n</td><td>指定设备数量</td></tr><tr><td>-l</td><td>指定RAID级别</td></tr><tr><td>-C</td><td>创建</td></tr><tr><td>-v</td><td>显示过程</td></tr><tr><td>-f</td><td>模拟设备损坏</td></tr><tr><td>-r</td><td>移除设备</td></tr><tr><td>-Q</td><td>查看摘要信息</td></tr><tr><td>-D</td><td>查看详细信息</td></tr><tr><td>-S</td><td>停止RAID磁盘阵列</td></tr><tr><td>-x</td><td>备份盘数量</td></tr></tbody></table></li></ul><p>mdadm -D &#x2F;dev&#x2F;md0显示的部分字段解释：</p><ul><li><p>Number: 这个字段表示每个磁盘在 RAID 阵列中的编号（从 0 开始）。这是 RAID 阵列中每个设备的索引或设备号。</p></li><li><p>Major: 这是设备文件的主设备号（major number），它用于标识设备的类型。不同的主设备号通常对应不同的驱动程序或设备类别。</p></li><li><p>Minor: 这是设备文件的次设备号（minor number），用于标识同一类型设备中的不同实例。主设备号和次设备号共同唯一标识系统中的一个设备。</p></li><li><p>RaidDevice: 这是设备在 RAID 阵列中的逻辑设备编号。通常从 0 开始，表示该设备在 RAID 阵列中的顺序。</p></li><li><p>State: 表示 RAID 阵列中该设备的当前状态。常见状态如下：<br>– active sync: 表示该设备处于活动状态，并且与 RAID 阵列中的其他设备同步。<br>– faulty: 表示设备出现故障，不能正常工作。<br>– spare: 表示该设备是热备盘，当其他设备故障时可自动替换。</p></li><li><p>set-A &#x2F; set-B: 这可能是与 RAID 10 或其他多组 RAID 配置相关的信息，表示该磁盘属于某个 RAID 子组或镜像组。例如，set-A 和 set-B 可能表示 RAID 10 配置中的两个镜像组。</p></li><li><p>&#x2F;dev&#x2F;nvme0nX: 这是设备的名称，表示设备在系统中的路径。在这里，设备是 NVMe 协议的磁盘（例如，&#x2F;dev&#x2F;nvme0n2）。不同的数字后缀（例如 n2, n3 等）表示不同的 NVMe 设备。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件包管理</title>
    <link href="/2025/10/25/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2025/10/25/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="软件包的类型"><a href="#软件包的类型" class="headerlink" title="软件包的类型"></a>软件包的类型</h1><ul><li>源码包<br>– 需要编译</li><li>二进制包<br>–已编译</li></ul><p>常见二进制包类型</p><ul><li>RedHat&#x2F;Centos<br>– RPM<br>– 工具<br>— rpm<br>— yum(在线安装，自动解决依赖关系)<br>— dnf(yum的升级版本，在RockyLinux中，yum命令是dnf的软连接)</li><li>Ubuntu&#x2F;Debain<br>– DPKG<br>– 工具<br>— dpkg<br>— apt(在线安装，自动解决依赖关系)<br>注意！不管是源码包，还是二进制包，安装时都可能会有依赖关系</li></ul><h1 id="yum-dnf"><a href="#yum-dnf" class="headerlink" title="yum&#x2F;dnf"></a>yum&#x2F;dnf</h1><p>yum&#x2F;dnf是红帽系列的发行版本上用来下载和安装软件包的一个工具<br>我们可以使用yum install xxx命令来安装一个软件</p><p>yum工具是去yum源找到这些软件包的,所谓源的意思就是指这些软件包的来源，也可以成称之为软件仓库</p><ul><li>dnf与yum的对比<br>– YUM (Yellowdog Updater, Modified)：是 RHEL 8 及之前版本使用的包管理工具。提供了一个简单的命令行接口，用来安装、更新、删除和管理 RPM 软件包。基于 Python 2 开发，在性能和依赖性解析方面存在一定的限制。<br>– DNF (Dandified YUM)：是 YUM 的下一代替代工具，首次在 Fedora 18 引入，并从 RHEL 8 开始逐步取代 YUM，到了 RHEL 9 完全淘汰 YUM。采用了更先进的依赖解析器和更高效的代码。基于 Python 3 开发，支持现代特性和技术，性能更高。</li></ul><p>RockyLinux中yum命令的本质：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost bin]# ll /usr/bin/ | grep dnf<br>lrwxrwxrwx. 1 root root          5 Apr 14  2024 dnf -&gt; dnf-3<br>-rwxr-xr-x. 1 root root       2094 Apr 14  2024 dnf-3<br>lrwxrwxrwx. 1 root root          5 Apr 14  2024 yum -&gt; dnf-3<br></code></pre></td></tr></table></figure><p>由此可以看出，yum命令和dnf命令都链接自dnf-3。实际上dnf-3才是包管理器的真正可执行程序，代表基于python3开发。这样链接是为了我们使用起来更方便。</p><h2 id="官方源"><a href="#官方源" class="headerlink" title="官方源"></a>官方源</h2><p>一些有名的大厂或者高校都有提供他们整合好的软件仓库：<br>阿里云镜像：<a href="https://mirrors.aliyun.com/rockylinux/">https://mirrors.aliyun.com/rockylinux/</a><br>腾讯云镜像：<a href="https://mirrors.cloud.tencent.com/rocky/">https://mirrors.cloud.tencent.com/rocky/</a><br>中科大镜像：<a href="https://mirrors.ustc.edu.cn/rocky/">https://mirrors.ustc.edu.cn/rocky/</a><br>上海交大镜像：<a href="https://mirrors.sjtug.sjtu.edu.cn/rocky/">https://mirrors.sjtug.sjtu.edu.cn/rocky/</a><br>西安交大镜像：<a href="https://mirrors.xjtu.edu.cn/rocky/">https://mirrors.xjtu.edu.cn/rocky/</a><br>浙江大学镜像：<a href="https://mirrors.zju.edu.cn/rocky/">https://mirrors.zju.edu.cn/rocky/</a><br>南京大学镜像：<a href="https://mirrors.nju.edu.cn/rocky/">https://mirrors.nju.edu.cn/rocky/</a><br>山东大学镜像：<a href="https://mirrors.sdu.edu.cn/rocky/">https://mirrors.sdu.edu.cn/rocky/</a><br>兰州大学镜像：<a href="https://mirror.lzu.edu.cn/rocky/">https://mirror.lzu.edu.cn/rocky/</a><br>大连东软镜像：<a href="https://mirrors.neusoft.edu.cn/rocky/">https://mirrors.neusoft.edu.cn/rocky/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum repolist        <span class="hljs-comment"># 查看现有的软件仓库</span><br>repo <span class="hljs-built_in">id</span>                                        repo name<br>appstream                                      Rocky Linux 9 - AppStream<br>baseos                                         Rocky Linux 9 - BaseOS<br>extras                                         Rocky Linux 9 - Extras<br><span class="hljs-comment">#软件源相关文件存放的位置/etc/yum.repos.d/</span><br>[root@localhost ~]# <span class="hljs-built_in">ls</span> /etc/yum.repos.d/<br>rocky-addons.repo  rocky-devel.repo  rocky-extras.repo  rocky.repo<br><span class="hljs-comment"># 这里面的一个个.repo文件就是一个个软件仓库可以尝试添加中科大软件仓库，下面的是RockyLinux的添加命令</span><br><span class="hljs-comment"># 备份原来的源</span><br>[root@localhost ~]# <span class="hljs-built_in">mkdir</span> /repobackup<br>[root@localhost ~]# <span class="hljs-built_in">cp</span> /etc/yum.repos.d/* /repobackup/<br><span class="hljs-comment"># 使用sed命令，替换原来repo文件中的内容</span><br>[root@localhost ~]# sed -e <span class="hljs-string">&#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;</span> \<br>    -e <span class="hljs-string">&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/rocky|g&#x27;</span> \<br>    -i.bak \<br>    /etc/yum.repos.d/rocky-extras.repo \<br>    /etc/yum.repos.d/rocky.repo<br><br><span class="hljs-comment"># 更新缓存</span><br>[root@localhost ~]# yum makecache<br>[root@localhost ~]# yum repolist<br>repo <span class="hljs-built_in">id</span>                                        repo name<br>appstream                                      Rocky Linux 9 - AppStream<br>baseos                                         Rocky Linux 9 - BaseOS<br>extras                                         Rocky Linux 9 - Extras<br></code></pre></td></tr></table></figure><p>EPEL源(Extra Packages for Enterprise Linux)为“红帽系”的操作系统提供额外的软件包<br>yum -y install epel-release</p><h2 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h2><h3 id="查看当前可用仓库"><a href="#查看当前可用仓库" class="headerlink" title="查看当前可用仓库"></a>查看当前可用仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum clean all        <span class="hljs-comment"># 清空缓存及其他文件</span><br>[root@localhost ~]# yum makecache        <span class="hljs-comment"># 重建缓存</span><br>[root@localhost ~]# yum repolist        <span class="hljs-comment"># 查询可用的仓库</span><br></code></pre></td></tr></table></figure><h3 id="查找软件包"><a href="#查找软件包" class="headerlink" title="查找软件包"></a>查找软件包</h3><p>注意：有些命令跟软件包的名字是不同的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 通过命令的名字查找是属于哪个软件包<br>[root@localhost ~]# yum provides pstree<br><br>2. 通过配置文件查找属于哪个软件包提供的<br>[root@localhost ~]# yum provides /etc/ssh/<br><br>3. 通过search参数查找软件包<br>[root@localhost ~]# yum search psmisc<br><br>4. 查看系统中的安装包<br>[root@localhost ~]# yum list installed            <span class="hljs-comment"># 查看已安装的所有软件包</span><br>[root@localhost ~]# yum list                    <span class="hljs-comment"># 查看所有可以安装的软件包</span><br>[root@localhost ~]# yum list httpd<br>安装软件包<br><span class="hljs-comment"># yum install xxx</span><br></code></pre></td></tr></table></figure><h3 id="安装httpd软件包"><a href="#安装httpd软件包" class="headerlink" title="安装httpd软件包"></a>安装httpd软件包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum install -y httpd <br>-y：一律允许<br>[root@localhost ~]# yum install -y httpd vim nginx         <span class="hljs-comment"># 多个软件包之间用空格隔开</span><br>[root@localhost ~]# yum reinstall httpd                    <span class="hljs-comment"># 重新安装</span><br>[root@localhost ~]# yum update httpd                     <span class="hljs-comment"># 更新软件包的版本-laster</span><br>[root@localhost ~]# yum update                             <span class="hljs-comment"># 更新所有软件包到软件仓库的最新版本</span><br><br><span class="hljs-comment"># 从本地安装</span><br>[root@localhost ~]# yum install -y httpd-2.4.57-11.el9_4.x86_64.rpm<br><br><span class="hljs-comment"># 从URL安装</span><br>[root@localhost ~]# yum install -y https://rpmfind.net/linux/almalinux/9.4/AppStream/x86_64/os/Packages/httpd-2.4.57-11.el9_4.x86_64.rpm<br></code></pre></td></tr></table></figure><h3 id="管理软件包组"><a href="#管理软件包组" class="headerlink" title="管理软件包组"></a>管理软件包组</h3><p>软件包组就是把一些相关的软件包给整合起来，可以打包安装和卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">export</span> LANG=<span class="hljs-string">&quot;en-US.utf8&quot;</span>            切换英文环境<br>[root@localhost ~]# yum grouplist<br>[root@localhost ~]# yum groupinfo <span class="hljs-string">&quot;Server with GUI&quot;</span><br>[root@localhost ~]# yum groupinstall <span class="hljs-string">&quot;Server with GUI&quot;</span><br>[root@localhost ~]# yum -y groupremove <span class="hljs-string">&quot;Server with GUI&quot;</span><br></code></pre></td></tr></table></figure><h4 id="切换图形化模式"><a href="#切换图形化模式" class="headerlink" title="切换图形化模式"></a>切换图形化模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#临时切换到图形化模式</span><br>[root@localhost ~]# systemctl isolate graphical.target<br><br><span class="hljs-comment">#永久切换（开机进入图形化）</span><br>[root@localhost ~]# systemctl set-default graphical.target<br><span class="hljs-comment"># 验证启动模式</span><br>[root@localhost ~]# systemctl get-default<br>multi-user.target<br><br><span class="hljs-comment">#临时切换到命令行模式</span><br>[root@localhost ~]# systemctl isolate multi-user.target<br><br><span class="hljs-comment">#永久切换</span><br>[root@localhost ~]# systemctl set-default multi-user.target<br><br><span class="hljs-comment">### 卸载</span><br>```bash<br>[root@localhost ~]# yum -y remove httpd                     <span class="hljs-comment"># 卸载httpd软件包</span><br>[root@localhost ~]# yum -y groupremove <span class="hljs-string">&quot;Server with GUI&quot;</span>        <span class="hljs-comment"># 卸载软件包组</span><br></code></pre></td></tr></table></figure><h3 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h3><p>用来查看 yum 软件包管理器的历史记录的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum <span class="hljs-built_in">history</span><br>[root@localhost ~]# yum <span class="hljs-built_in">history</span> info 4                    <span class="hljs-comment"># 查看具体某个yum记录的信息</span><br></code></pre></td></tr></table></figure><h1 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h1><p>在RHEL系列的系统上所使用的软件包为rpm包，上面使用的yum为在线安装软件包。除了在线的安装方法，我们还可以将rpm包下载到本地，然后使用rpm工具来安装这个软件包</p><ul><li>rpm工具使用分为安装、查询、验证、更新、删除等操作</li><li>rpm包的格式说明：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@atopos ~]# rpm -ivh httpd-2.4.6-93.el7.centos.x86_64.rpm<br>- httpd：包名<br>- 2：主版本号<br>- 4：次版本号<br>- 6：修订次数，指的是第几次修改bug<br>- 93：release（第几次发布，指的是简单的修改参数）<br>- e17：操作系统版本<br>- x86_64：64位操作系统<br></code></pre></td></tr></table></figure><p>命令格式<br>[root@atopos ~]# rpm [选项] 软件包</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li>安装：<br>– -i：install的意思，安装软件包<br>– -v：显示附加信息，提供更多详细信息<br>– -V：校验，对已安装的软件进行校验</li><li>查询：<br>– -q：查询，一般跟下面的参数配合使用<br>– -a：查询所有已安装的软件包<br>– -f：系统文件名（查询系统文件属于哪个安装包）<br>– -i：显示已安装的rpm软件包信息<br>– -l：查询软件包文件的安装位置<br>– -p：查询未安装软件包的相关信息<br>– -R：查询软件包的依赖性</li><li>卸载：<br>– -e：erase<br>– –nodeps：忽略依赖</li><li>升级：<br>– -U：一般配合vh使用</li></ul><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><ul><li>-ivh：安装</li><li>-uvh：更新</li><li>-qa：查询所有软件包</li><li>-qi：已安装软件包的详细信息</li><li>-ql：查询软件包在系统上安装的文件</li><li>-qc：查询软件包安装时安装了哪些配置文件</li></ul><h1 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h1><p>源码包获得途径：</p><ul><li>官方网站<br>– apache: <a href="http://www.apache.org/">www.apache.org</a><br>– nginx: <a href="http://www.nginx.org/">www.nginx.org</a></li><li>github<br>– <a href="http://www.github.com/">www.github.com</a><br>编译源码包所需要的环境<br>这取决于源码所使用的编程语言和框架等，但是Linux基础软件包一般都是由C语言编写的，所以我们使用较多的编译环境为gcc、make等等<br>yum install -y ncurses* gcc gcc-c++ make</li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>源码包编译三部曲</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">- 第一步：<br>./configure <br><span class="hljs-comment">#可以指定安装路径，启用或者禁用功能等，最终生成makefile</span><br><br>- 第二步<br>make <br><span class="hljs-comment">#按Makefile文件编译。可以加 -j 2 参数使用两个cpu核心进行编译</span><br><br>- 第三步<br>make install<br><span class="hljs-comment">#按Makefile定义的文件路径安装</span><br><br>make clean<br><span class="hljs-comment">#清除上一次make命令所产生的object文件，要重新执行</span><br>configure时，需要执行make clean。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>防火墙与selinux</title>
    <link href="/2025/10/25/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8Eselinux/"/>
    <url>/2025/10/25/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8Eselinux/</url>
    
    <content type="html"><![CDATA[<h1 id="防火墙相关概念"><a href="#防火墙相关概念" class="headerlink" title="防火墙相关概念"></a>防火墙相关概念</h1><p>主要作用：保护内部的网络、主机、服务的安全等<br>我们常听到的防火墙有很多不同的类型，从大的角度来看，主要是分为硬件防火墙和软件防火墙。</p><p>软件防火墙：<br>软件防火墙就是通过软件来对数据包，流量请求进行过滤等，属于从软件层面保护系统的安全。如我们熟知的360，金山毒霸，火绒安全等等。<br>当然防火墙除了软件及硬件的分类，也可以对数据封包的取得方式来分类，可分为代理服务器（Proxy）及封包过滤机制（IP Filter）。</p><ul><li>代理服务<br>– 是一种网络服务，通常就架设在路由上面，可完整的掌控局域网的对外连接。</li><li>IP Filter<br>– 这种方式可以直接分析最底层的封包表头数据来进行过滤，所以包括 MAC地址, IP, TCP, UDP, ICMP 等封包的信息都可以进行过滤分析的功能，用途非常广泛。</li></ul><p>相较于企业内网，外部的公网环境更加恶劣，罪恶丛生。在公网与企业内网之间充当保护屏障的防火墙虽然有软件或硬件之分，但主要功能都是依据策略对穿越防火墙自身的流量进行过滤。防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就可以保证仅有合法的流量在企业内网和外部公网之间流动了</p><h1 id="RHEL-Centos系统"><a href="#RHEL-Centos系统" class="headerlink" title="RHEL&#x2F;Centos系统"></a>RHEL&#x2F;Centos系统</h1><p>对于RHEL、Centos等红帽系Linux操作系统，我们常用到的防火墙软件主要有iptables和firewalld</p><ul><li><p>iptables:<br>– iptables 是 Linux 默认的防火墙管理工具,它是基于命令行的。<br>– iptables 使用规则表(tables)和规则链(chains)的方式来控制网络数据包的流向和处理。<br>– iptables 提供了强大的灵活性和细粒度的控制,可以根据数据包的各种属性进行复杂的过滤和转发操作。<br>– iptables 的配置相对比较复杂,需要对防火墙的工作原理有一定的了解。</p></li><li><p>firewalld:<br>– firewalld 是 RHEL&#x2F;CentOS 7 及以后版本中引入的动态防火墙管理工具。<br>– firewalld 采用区域(zones)和服务(services)的概念来管理防火墙规则,相比 iptables 更加简单和易用。<br>– firewalld 支持动态更新防火墙规则,无需重启服务即可生效,这对于需要经常调整防火墙的场景很有帮助。<br>– firewalld 提供了图形化的管理界面,方便管理员进行配置和管理。</p></li></ul><p>不过，对于Linux而言，其实Iptables和firewalld服务不是真正的防火墙，只是用来定义防火墙规则功能的”防火墙管理工具”，将定义好的规则交由内核中的netfilter即网络过滤器来读取，从而真正实现防火墙功能。</p><h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><p>iptables过滤数据包的方式：</p><ul><li>允许&#x2F;拒绝让 Internet 的封包进入 Linux 主机的某些 port</li><li>允许&#x2F;拒绝让某些来源 IP 的封包进入</li><li>允许&#x2F;拒绝让带有某些特殊标志( flag )的封包进入</li><li>分析硬件地址(MAC)来提供服务</li></ul><h2 id="五链"><a href="#五链" class="headerlink" title="五链"></a>五链</h2><p>iptables命令中设置数据过滤或处理数据包的策略叫做规则，将多个规则合成一个链，叫规则链。规则链则依据处理数据包的位置不同分类：</p><ul><li>PREROUTING 在进行路由判断之前所要进行的规则(DNAT&#x2F;REDIRECT)</li><li>INPUT 处理入站的数据包</li><li>OUTPUT 处理出站的数据包</li><li>FORWARD 处理转发的数据包</li><li>POSTROUTING 在进行路由判断之后所要进行的规则(SNAT&#x2F;MASQUERADE)</li></ul><h2 id="四表"><a href="#四表" class="headerlink" title="四表"></a>四表</h2><p>iptables中的规则表是用于容纳规则链，规则表默认是允许状态的，那么规则链就是设置被禁止的规则，而反之如果规则表是禁止状态的，那么规则链就是设置被允许的规则。</p><ul><li>raw表 确定是否对该数据包进行状态跟踪</li><li>mangle表 为数据包设置标记（较少使用）</li><li>nat表 修改数据包中的源、目标IP地址或端口</li><li>filter表 确定是否放行该数据包（过滤）</li></ul><p>规则链的先后顺序:</p><ul><li>入站顺序<br>PREROUTING→INPUT<br>-出站顺序<br>OUTPUT→POSTROUTING</li><li>转发顺序<br>PREROUTING→FORWARD→POSTROUTING</li></ul><p>基本选项和用法<br>选项</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-P</td><td>设置默认策略:iptables -P INPUT (DROP\ACCEPT)类似于黑白名单</td></tr><tr><td>-F</td><td>清空规则链</td></tr><tr><td>-L</td><td>查看规则链</td></tr><tr><td>-A</td><td>在规则链的末尾加入新规则</td></tr><tr><td>-I num</td><td>在规则链的头部加入新规则</td></tr><tr><td>-D num</td><td>删除某一条规则</td></tr><tr><td>-j</td><td>指定动作</td></tr><tr><td>-s</td><td>匹配来源地址IP&#x2F;MASK，加叹号”!”表示除这个IP外。</td></tr><tr><td>-d</td><td>匹配目标地址</td></tr><tr><td>-i 网卡名称</td><td>匹配从这块网卡流入的数据</td></tr><tr><td>-o 网卡名称</td><td>匹配从这块网卡流出的数据</td></tr><tr><td>-p</td><td>匹配协议,如tcp,udp,icmp</td></tr><tr><td>–dports num</td><td>匹配目标端口号</td></tr><tr><td>–sports num</td><td>匹配来源端口号</td></tr><tr><td>为了防止firewalld与iptables的冲突，建议在学习iptables的时候，先关闭firewalld</td><td></td></tr></tbody></table><h2 id="iptables规则说明"><a href="#iptables规则说明" class="headerlink" title="iptables规则说明"></a>iptables规则说明</h2><p>规则：根据指定的匹配条件来尝试匹配每个经流“关卡”的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理</p><ul><li><p>匹配条件<br>– 基本匹配条件：sip、dip<br>– 扩展匹配条件：sport、dport<br>– 扩展条件也是条件的一部分，只不过使用的时候需要用-m参数声明对应的模块</p></li><li><p>处理动作-j<br>– accept：接受<br>– drop：丢弃<br>– reject：拒绝<br>– snat：源地址转换，解决内网用户同一个公网地址上上网的问题<br>– masquerade：是snat的一种特殊形式，使用动态的、临时会变的ip上<br>– dnat：目标地址转换<br>– redirect：在本机作端口映射<br>– log：记录日志，&#x2F;var&#x2F;log&#x2F;messages文件记录日志信息，然后将数据包传递给下一条规则</p></li></ul><h2 id="iptables高级用法"><a href="#iptables高级用法" class="headerlink" title="iptables高级用法"></a>iptables高级用法</h2><ul><li>-t table指定表<br>– raw<br>– mangle<br>– nat<br>– filter 默认</li><li>-A：添加规则，后面更上你要添加到哪个链上</li><li>-j：设置处理策略<br>– accept：接受<br>– drop：丢弃<br>– reject：拒绝</li><li>-s：指定数据包的来源地址</li><li>-p：指定数据包协议类型<br>– tcp<br>– udp<br>– icmp<br>……</li></ul><h3 id="增加规则"><a href="#增加规则" class="headerlink" title="增加规则"></a>增加规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在虚拟机上屏蔽来自我们物理机的ping包，注意物理机的IP的地址为：192.168.xxx.1</span><br><span class="hljs-comment"># ping命令是基于icmp协议的，所以这里对类型为icmp协议的数据包进行丢弃</span><br>[root@localhost ~]# iptables -A INPUT -s 192.168.88.1 -p icmp -j DROP<br><br>`其他用法`<br>[root@localhost ~]# iptables -A INPUT -s 192.168.88.100 -j ACCEPT<br><span class="hljs-comment"># 目标来自 192.168.88.100 这个 IP 的封包都予以接受</span><br>[root@localhost ~]# iptables -A INPUT -s 192.168.88.0/24 -j ACCEPT<br>[root@localhost ~]# iptables -A INPUT -s 192.168.88.10 -j DROP<br><span class="hljs-comment"># 192.168.88.0/24 可接受，但 192.168.88.10 丢弃</span><br></code></pre></td></tr></table></figure><p>INPUT 链：处理目标是本机的数据包。<br>OUTPUT 链：处理从本机发出的数据包。<br>要阻止一个通信，您需要想清楚是要阻断请求还是回复，然后选择正确的链。<br>匹配规则是从上往下匹配的</p><p>屏蔽Linux系统中的远程链接服务（sshd），使得我们无法通过MobaXterm连接到虚拟机上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT<br><span class="hljs-comment"># ssh服务所用的协议类型为tcp协议，端口号为22</span><br><span class="hljs-comment"># 所以我们将来自22端口上的tcp协议数据包给拒绝</span><br></code></pre></td></tr></table></figure><h3 id="查看规则"><a href="#查看规则" class="headerlink" title="查看规则"></a>查看规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables [-t tables] [-L] [-nv]<br>参数：<br>-t    后面接table,例如nat或filter，如果省略，默认显示filter<br>-L    列出目前的table的规则<br>-n    不进行IP与主机名的反查，显示信息的速度会快很多<br>-v    列出更多的信息，包括封包数，相关网络接口等<br>--line-numbers 显示规则的序号<br></code></pre></td></tr></table></figure><ul><li>查看具体每个表的规则:<br>– policy：当前链的默认策略，当所有规则都没有匹配成功时执行的策略<br>– packets：当前链默认策略匹配到的包的数量<br>– bytes：当前链默认策略匹配到的包的大小<br>– pkts：对应规则匹配到的包数量<br>– bytes：对应规则匹配到的包大小<br>– target：对应规则执行的动作<br>– prot：对应的协议，是否针对某些协议应用此规则<br>– opt：规则对应的选项<br>– in：数据包由哪个接口流入<br>– out：数据包由哪个接口流出<br>– source：源ip地址<br>– distination：目的ip地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -nvL INPUT --line-numbers<br><span class="hljs-comment">#查看INPUT链的规则</span><br>[root@localhost ~]# iptables -vnL INPUT -t filter --line-numbers<br>[root@localhost ~]# iptables -nL -t nat<br>[root@localhost ~]# iptables -nL -t mangle<br>[root@localhost ~]# iptables -nL -t raw<br></code></pre></td></tr></table></figure><h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p>通过上面学习的查看规则的方法，先查找到你想要删除的规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 举例</span><br><span class="hljs-comment"># 查看nat表上所有链的规则</span><br>[root@localhost ~]# iptables -t nat -nL --line-numbers<br><span class="hljs-comment"># 查看filter（默认表）上所有链的规则</span><br>[root@localhost ~]# iptables -nL --line-numbers<br></code></pre></td></tr></table></figure><ul><li>通过num序号进行删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#删除input链上num为1的规则</span><br>[root@localhost ~]# iptables -D INPUT 1<br></code></pre></td></tr></table></figure><ul><li>通过规则匹配删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -D INPUT -p tcp --dport 80 -j DROP<br></code></pre></td></tr></table></figure><ul><li>清空所有的规则</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -F<br></code></pre></td></tr></table></figure><h3 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h3><ul><li>方案一：通过iptables -D删除原有的规则后添加新的规则</li><li>方案二：通过iptables -R可以对具体某一个num的规则进行修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改端口的为8080</span><br>[root@localhost ~]# iptables -R INPUT 1 -p tcp --dport 8080 -j ACCEPT<br><br><span class="hljs-comment"># 针对具体的某一个表和链进行修改</span><br><span class="hljs-comment"># 将8080修改回80</span><br>[root@localhost ~]# iptables -t filter -R INPUT 1 -p tcp --dport 80 -j ACCEPT<br></code></pre></td></tr></table></figure><h2 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h2><p>iptables中除了系统自带的五个链之外，还可以自定义链，来实现将规则进行分组，重复调用的目的<br>具体方法见如下案例：</p><ul><li>案例一：我们自定义一个WEB_CHAIN链，专门管理跟web网站相关的规则策略</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 先查看我们现有的系统链</span><br>[root@localhost ~]# iptables -L<br>Chain INPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>Chain FORWARD (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>Chain OUTPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br><br><span class="hljs-comment"># 2. 添加WEB_CHAIN自定义链，并且查看</span><br>[root@localhost ~]# iptables -t filter -N web_chain<br>[root@localhost ~]# iptables -L<br>..........<br>Chain web_chain (0 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br><br><span class="hljs-comment"># 3. 可以通过-E参数修改自定义链</span><br>[root@localhost ~]# iptables -t filter -E web_chain WEB_CHAIN<br>[root@localhost ~]# iptables -L<br>.........<br>Chain WEB_CHAIN (0 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br><span class="hljs-comment"># 可以看到名字已经发生变化了</span><br><br><span class="hljs-comment"># 4. 向我们创建的自定义链中添加规则，开放80端口上的服务</span><br>[root@localhost ~]# iptables -t filter -A WEB_CHAIN -p tcp -m multiport --dports 80,443 -j ACCEPT<br><br><span class="hljs-comment"># 5. 将自定义链关联到系统链上才能使用</span><br><span class="hljs-comment"># 因为数据包只会经过上面讲过的五个系统链，不会经过我们的自定义链，所以需要把自定义链关联到某个系统链上</span><br><br><span class="hljs-comment"># 我们允许来自IP：192.168.88.1的访问，随后拒绝其他所有的访问，这样，只有192.168.88.1的主机可以访问这个网站</span><br>[root@localhost ~]# iptables -t filter -A INPUT -s 192.168.88.1 -j WEB_CHAIN<br>[root@localhost ~]# iptables -t filter -A INPUT -p tcp -m multiport --dports 80,443 -j DROP<br>[root@localhost ~]# iptables -L<br>Chain INPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>WEB_CHAIN  all  --  192.168.88.1         anywhere<br>Chain FORWARD (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>Chain OUTPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>Chain WEB_CHAIN (1 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:http<br><br>- 删除自定义链<br><span class="hljs-comment"># 先清空自定义链上的规则</span><br>[root@localhost ~]# iptables -t filter -F WEB_CHAIN<br><span class="hljs-comment"># 然后通过-X选项删除自定义链</span><br>[root@localhost ~]# iptables -t filter -X WEB_CHAIN<br></code></pre></td></tr></table></figure><h2 id="其他用法（模块）"><a href="#其他用法（模块）" class="headerlink" title="其他用法（模块）"></a>其他用法（模块）</h2><ul><li>tcp&#x2F;udp<br>– –dport：指定目的端口<br>– –sport：指定源端口</li><li>iprange：匹配报文的源&#x2F;目的地址所在范围<br>– –src-range<br>– –dst-range</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A INPUT -d 172.16.1.100 -p tcp --dport 80 -m iprange --src-range 172.16.1.5-172.16.1.10 -j DROP<br></code></pre></td></tr></table></figure><ul><li>string：指定匹配报文中的字符串<br>– –algo：指定匹配算法，可以是bm&#x2F;kmp<br>— bm：Boyer-Moore<br>— kmp：Knuth-Pratt-Morris<br>– –string：指定需要匹配的字符串<br>– –from offset：开始偏移<br>– –to offset：结束偏移</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A OUTPUT -p tcp --sport 80 -m string --algo bm --from 62  --string <span class="hljs-string">&quot;google&quot;</span> -j REJECT<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum -y install httpd<br>[root@localhost ~]# systemctl start httpd<br>[root@localhost ~]# systemctl <span class="hljs-built_in">enable</span> httpd<br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span> &gt; /var/www/html/index.html<br>[root@localhost ~]# iptables -A OUTPUT -p tcp --sport 80 -m string --algo bm --string <span class="hljs-string">&quot;world&quot;</span> -j REJECT<br><span class="hljs-comment">#用浏览器刷新页面发现打不开</span><br>[root@localhost ~]# iptables -nL<br>Chain INPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>Chain FORWARD (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>Chain OUTPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br>REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp spt:80 STRING match  <span class="hljs-string">&quot;world&quot;</span> ALGO name bm TO 65535 reject-with icmp-port-unreachable<br><br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;h1&gt;hello XHZ&lt;/h1&gt;&quot;</span> &gt; /var/www/html/index.html<br><span class="hljs-comment"># 此时浏览器打开成功</span><br></code></pre></td></tr></table></figure><ul><li>time：指定匹配报文的时间<br>– –timestart<br>– –timestop<br>– –weekdays<br>– –monthdays<br>– –datestart<br>– –datestop</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A INPUT -s 172.16.0.0/16 -d 172.16.100.10 -p tcp --dport 80 -m <span class="hljs-keyword">time</span> --timestart 14:30 --timestop 18:30 --weekdays Sat,Sun  -j DROP<br><br>-m <span class="hljs-keyword">time</span> --timestart 14:30 --timestop 18:30 --weekdays Sat,Sun：在指定的时间范围内生效，即从周六到周日的14:30到18:30之间。这表示该规则只在这个时间段内生效<br><br>- 该规则的作用是在指定时间范围内，阻止来自172.16.0.0/16网段源IP地址、目标IP地址为172.16.100.10、目标端口为80的TCP数据包进入系统<br></code></pre></td></tr></table></figure><ul><li>connlimit：限制每个ip连接到server端的数量，不需要指定ip默认就是针对每个ip地址,可防止Dos(Denial of Service，拒绝服务)攻击<br>– –connlimit-above：最大连接数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A INPUT -d 172.16.100.10 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT<br><br>-m connlimit --connlimit-above 2：使用连接限制模块，限制连接数超过2的数据包。这表示如果同一源IP地址的连接数超过2个，将匹配到该规则<br><br>- 该规则的作用是限制目标IP地址为172.16.100.10、目标端口为22的数据包，如果同一源IP地址的连接数超过2个，则拒绝回复该数据包。这个规则可以用于防止对SSH服务的暴力破解攻击，限制来自同一IP地址的并发连接数<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A INPUT -s 192.168.88.0/24 -p tcp --dport 22 -m connlimit --connlimit-above 2 -j REJECT<br><br><span class="hljs-comment">#此时登第三个终端，会登不上</span><br>[root@localhost ~]# iptables -nL --line-numbers<br>Chain INPUT (policy ACCEPT)<br>num  target     prot opt <span class="hljs-built_in">source</span>               destination<br>1    DROP       tcp  --  172.16.0.0/16        172.16.100.10        tcp dpt:80 TIME from 14:30:00 to 18:30:00 on Sat,Sun UTC<br>2    REJECT     tcp  --  192.168.88.0/24      0.0.0.0/0            tcp dpt:22 <span class="hljs-comment">#conn src/32 &gt; 2 reject-with icmp-port-unreachable</span><br><br>[root@Centos7-VM-1 ~]# iptables -D INPUT 2<br></code></pre></td></tr></table></figure><ul><li>limit：对报文到达的速率继续限制，限制包数量<br>– 10&#x2F;second<br>– 10&#x2F;minute<br>– 10&#x2F;hour<br>– 10&#x2F;day<br>– –limit-burst：空闲时可放行的包数量，默认为5，前多少个包不限制</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -A INPUT -p icmp -m <span class="hljs-built_in">limit</span> --limit-burst 10 --<span class="hljs-built_in">limit</span> 20/minute -j ACCEPT<br>iptables -A INPUT -p icmp  -j REJECT<br><br>--limit-burst 10：设置允许的初始突发量为10个数据包。<br>--<span class="hljs-built_in">limit</span> 20/minute：设置平均速率为20个数据包/分钟，即每分钟允许通过的ICMP数据包数量为20个。<br><br>- 该规则的作用是限制ICMP数据包的速率，允许初始突发量为10个数据包，以后每分钟最多允许通过20个ICMP数据包。匹配到的ICMP数据包将被接受，其他超出限制的数据包将被丢弃。这个规则可以用于控制对系统的ICMP流量，以避免过多的ICMP请求对系统造成负载过大的影响<br></code></pre></td></tr></table></figure><ul><li>指定TCP匹配扩展</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">使用 --tcp-flags 选项可以根据tcp包的标志位进行过滤。<br>[root@localhost ~]# iptables -A INPUT -p tcp --tcp-flags SYN,FIN,ACK SYN<br>[root@localhost ~]# iptables -A FROWARD -p tcp --tcp-flags ALL SYN,ACK<br>上实例中第一个表示SYN、ACK、FIN的标志都检查，但是只有SYN匹配。第二个表示ALL（SYN，ACK，FIN，RST，URG，PSH）的标志都检查，但是只有设置了SYN和ACK的匹配。<br>[root@localhost ~]# iptables -A FORWARD -p tcp --syn<br>选项--syn相当于<span class="hljs-string">&quot;--tcp-flags SYN,RST,ACK SYN&quot;</span>的简写。<br></code></pre></td></tr></table></figure><ul><li>state模块：用于针对tcp连接进行限制，较耗资源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# iptables -A INPUT -m 模块名 --state 状态<br>参数：<br>-m    iptables的模块<br>        state: 状态检查<br>        mac:网卡硬件地址<br>--state     连接追踪中的状态：<br>        NEW: 新建立一个会话<br>        ESTABLISHED：已建立的连接<br>        RELATED: 有关联关系的连接<br>        INVALID: 无法识别的连接<br>[root@localhost ~]# iptables -A INPUT -p tcp --dport 22 -m state --state NEW -j ACCEPT    <br>-m state --state NEW：使用状态模块，匹配数据包的连接状态为NEW，即新建的连接。<br>- 该规则的作用是允许进入系统的TCP数据包，目标端口为22（SSH服务），且连接状态为NEW（新建的连接）。这个规则用于允许建立新的SSH连接，而拒绝已经建立的或结束的连接<br><br>[root@localhost ~]# iptables -A INPUT -m mac --mac-source 00:0C:29:56:A6:A2 -j ACCEPT<br>-m mac --mac-source 00:0C:29:56:A6:A2：使用MAC模块，匹配源MAC地址为00:0C:29:56:A6:A2的数据包<br>- 该规则的作用是允许源MAC地址为00:0C:29:56:A6:A2的数据包进入系统。这个规则可以用于根据MAC地址限制网络访问，只允许特定的MAC地址通过防火墙进入系统<br></code></pre></td></tr></table></figure><h2 id="规则的保存与恢复"><a href="#规则的保存与恢复" class="headerlink" title="规则的保存与恢复"></a>规则的保存与恢复</h2><p>用规则文件保存各规则，开机后导入该规则文件中的规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 保存到文件中</span><br>[root@localhost ~]# iptables-save &gt; /etc/sysconfig/iptables-config<br><span class="hljs-comment"># 从文件中导入规则</span><br>[root@localhost ~]# iptables-restore &lt; /etc/sysconfig/iptables-config<br></code></pre></td></tr></table></figure><p>安装iptables-services，在centos7和centos8上，通过该服务来帮助我们自动管理iptables规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum -y install iptables-services<br>[root@localhost ~]# systemctl start iptables.service<br>[root@localhost ~]# systemctl <span class="hljs-built_in">enable</span> iptables.service<br></code></pre></td></tr></table></figure><h2 id="NAT（地址转换协议）"><a href="#NAT（地址转换协议）" class="headerlink" title="NAT（地址转换协议）"></a>NAT（地址转换协议）</h2><p>​网络地址转换 NAT（Network Address Translation），被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。原因很简单，NAT 不仅完美地解决了 IP 地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。默认情况下，内部 IP 地址是无法被路由到外网的，内部主机 10.1.1.1 要与外部 Internet通信，IP 包到达 NAT 路由器时，IP 包头的源地址 10.1.1.1 被替换成一个合法的外网 IP，并在 NAT 转发表中保存这条记录。当外部主机发送一个应答到内网时，NAT 路由器收到后，查看当前 NAT 转换表，用 10.1.1.1 替换掉这个外网地址。NAT 将网络划分为内部网络和外部网络两部分，局域网主机利用 NAT 访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的 IP 地址）后转发数据包</p><h1 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h1><p>firewalld是CentOS 7.0新推出的管理netfilter的用户空间软件工具<br>并且支持划分区域zone,每个zone可以设置独立的防火墙规则</p><ul><li>流量的规则匹配顺序<br>– 先根据数据包中源地址，将其纳为某个zone<br>– 纳为网络接口所属zone<br>– 纳入默认zone，默认为public zone,管理员可以改为其它zone</li><li>firewalld中常用的区域名称及策略规则<table><thead><tr><th>区域</th><th>默认策略规则</th><th>适用场景</th></tr></thead><tbody><tr><td>public</td><td>默认区域,对应普通网络环境。允许选定的连接,拒绝其他连接</td><td>普通网络环境</td></tr><tr><td>drop</td><td>所有传入的网络包都会被直接丢弃,不会发送任何响应</td><td>最高安全级别，不响应任何传入请求</td></tr><tr><td>block</td><td>所有传入的网络包会被拒绝,并发送拒绝信息</td><td>高安全级别，但会告知对方连接被拒绝</td></tr><tr><td>external</td><td>用于路由&#x2F;NAT流量的外部网络环境。与public类似,更适用于网关、路由器等处理外部网络流量的设备</td><td>网关、路由器等处理外部网络流量的设备</td></tr><tr><td>dmz</td><td>隔离区域,只允许选定的连接，适用于部署公开服务的网络区域,可以最大限度地降低内部网络的风险</td><td>部署公开服务的网络区域，如Web服务器</td></tr><tr><td>work</td><td>适用于工作环境，开放更多服务,如远程桌面、文件共享等。比public区域更加信任</td><td>工作环境，需要更多服务访问</td></tr><tr><td>home</td><td>适用于家庭环境，开放更多服务，比如默认情况下会开放一些如:3074端口(Xbox)、媒体、游戏数据等待</td><td>家庭环境，需要多媒体、游戏等服务</td></tr><tr><td>trusted</td><td>信任区域,允许所有连接</td><td>完全信任的网络环境</td></tr></tbody></table></li></ul><h2 id="管理工具-firewall-cmd"><a href="#管理工具-firewall-cmd" class="headerlink" title="管理工具-firewall-cmd"></a>管理工具-firewall-cmd</h2><ul><li>firewall-cmd命令常用的选项<table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>--get-default-zone</code></td><td>查询默认的区域名称</td></tr><tr><td><code>--set-default-zone=&lt;区域名称&gt;</code></td><td>设置默认的区域，使其永久生效</td></tr><tr><td><code>--get-zones</code></td><td>显示可用的区域</td></tr><tr><td><code>--get-services</code></td><td>显示预先定义的服务</td></tr><tr><td><code>--get-active-zones</code></td><td>显示当前正在使用的区域与网卡名称</td></tr><tr><td><code>--add-source=</code></td><td>将源自此IP或子网的流量导向指定的区域</td></tr><tr><td><code>--remove-source=</code></td><td>不再将源自此IP或子网的流量导向某个指定区域</td></tr><tr><td><code>--add-interface=&lt;网卡名称&gt;</code></td><td>将源自该网卡的所有流量都导向某个指定区域</td></tr><tr><td><code>--change-interface=&lt;网卡名称&gt;</code></td><td>将某个网卡与区域进行关联</td></tr><tr><td><code>--list-all</code></td><td>显示当前区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td><code>--list-all-zones</code></td><td>显示所有区域的网卡配置参数、资源、端口以及服务等信息</td></tr><tr><td><code>--add-service=&lt;服务名&gt;</code></td><td>设置默认区域允许该服务的流量</td></tr><tr><td><code>--add-port=&lt;端口号/协议&gt;</code></td><td>设置默认区域允许该端口的流量</td></tr><tr><td><code>--remove-service=&lt;服务名&gt;</code></td><td>设置默认区域不再允许该服务的流量</td></tr><tr><td><code>--remove-port=&lt;端口号/协议&gt;</code></td><td>设置默认区域不再允许该端口的流量</td></tr><tr><td><code>--reload</code></td><td>让”永久生效”的配置规则立即生效，并覆盖当前的配置规则</td></tr><tr><td><code>--panic-on</code></td><td>开启应急状况模式</td></tr><tr><td><code>--panic-off</code></td><td>关闭应急状况模式</td></tr><tr><td><code>--permanent</code></td><td>设定的当前规则保存到本地，下次重启生效</td></tr></tbody></table></li></ul><h2 id="简单用法（初体验）"><a href="#简单用法（初体验）" class="headerlink" title="简单用法（初体验）"></a>简单用法（初体验）</h2><p>通过web服务部署一个网站,然后访问测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum -y install httpd<br>[root@localhost ~]# systemctl start httpd<br>在浏览器中输入192.168.88.136访问测试发现，我们无法访问此网站，这是因为默认情况下，firewalld是出于开启的状态，并且默认区域为public。在public区域中，除了部分系统服务，其他服务的流量一律是禁止的。<br><br><br><span class="hljs-comment"># 查看当前所在的区域</span><br>[root@localhost ~]# firewall-cmd --get-default-zone<br>public<br><span class="hljs-comment"># 查看当前网卡所在的区域</span><br>[root@localhost ~]# firewall-cmd --get-zone-of-interface=ens160<br>public<br><br><span class="hljs-comment"># 查询public区域是否允许请求SSH或者HTTP协议的流量</span><br>[root@localhost ~]# firewall-cmd --zone=public --query-service=ssh<br><span class="hljs-built_in">yes</span><br>[root@localhost ~]# firewall-cmd --zone=public --query-service=http<br>no<br>`可以看出，在public区域中，默认是禁止来自http协议的请求数据包的`<br><br><span class="hljs-comment">#修改firewalld策略,使得我们可以访问到刚刚部署的网站</span><br>- 方法一：针对服务协议类型进行放行<br><span class="hljs-comment"># 临时放行</span><br>[root@localhost ~]# firewall-cmd --zone=public --add-service=http<br><span class="hljs-comment"># 可以加上--permanent实现永久放行</span><br>[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=http<br><br>- 方法二：针对服务具体访问请求的端口号进行放行<br>[root@localhost ~]# firewall-cmd --zone=public --add-port=80/tcp<br>success<br><span class="hljs-comment"># 同样也可以加上--permanent实现永久放行</span><br><br><span class="hljs-comment">#取消放行</span><br>[root@localhost ~]# firewall-cmd --zone=public --remove-service=http --permanent<br>success<br></code></pre></td></tr></table></figure><h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#把firewalld服务的当前默认区域设置为public</span><br>[root@localhost ~]# firewall-cmd --set-default-zone=public<br><br><span class="hljs-comment">#查看某个区域的详细配置</span><br>[root@localhost ~]# firewall-cmd --zone=public --list-all<br><br><span class="hljs-comment">#将firewalld 切换到紧急模式(panic mode)。这种模式下,firewalld 会采取一种非常严格的防护策略:所有传入的网络连接都会被拒绝,除了 ssh 和 ICMP 回送(ping)请求。所有区域的防火墙规则都会被重置为默认的严格策略。所有区域的默认策略都会被设置为 DROP</span><br>[root@localhost ~]# firewall-cmd --panic-on<br><span class="hljs-comment"># 取消紧急模式</span><br>[root@localhost ~]# firewall-cmd --panic-off<br><br><span class="hljs-comment"># 临时生效</span><br>[root@localhost ~]# firewall-cmd --zone=public --add-service=http<br>success<br><span class="hljs-comment"># 永久生效，加了--permanent所进行的更改，会被写入到配置文件中，下次开机任然生效</span><br>[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=http<br>success<br><span class="hljs-comment"># 使得最近对防火墙规则变更或者所作的修改生效</span><br>[root@localhost ~]# firewall-cmd --reload<br>success<br>[root@localhost ~]# firewall-cmd --zone=public --query-service=http<br><span class="hljs-built_in">yes</span><br><br>-配置文件路径<br>/etc/firewalld/zones/public.xml<br>/etc/firewalld/direct.xml<br>/etc/firewalld/firewalld.conf<br><br><span class="hljs-comment">#把firewalld服务中请求HTTPS协议的流量设置为永久拒绝，并立即生效</span><br>[root@localhost ~]# firewall-cmd --zone=public --remove-service=https --permanent<br>success<br>[root@localhost ~]# firewall-cmd --reload<br>success<br><br><span class="hljs-comment">#把在firewalld服务中访问8080和8081端口的流量策略设置为允许，当前生效</span><br><span class="hljs-comment"># 可以指定要开放端口的范围</span><br>[root@localhost ~]# firewall-cmd --zone=public --add-port=8080-8081/tcp<br>success<br>[root@localhost ~]# firewall-cmd --zone=public --list-ports<br>8080-8081/tcp<br></code></pre></td></tr></table></figure><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#通过firewalld，将用户访问服务器上6666端口的流量转发到22端口上，实现本地端口映射。我们就可以使用6666端口来远程连接到服务器</span><br>[root@localhost ~]# firewall-cmd --permanent --add-forward-port=port=6666:proto=tcp:toport=22<br>success<br>[root@localhost ~]# firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="firewalld富规则"><a href="#firewalld富规则" class="headerlink" title="firewalld富规则"></a>firewalld富规则</h2><p>富规则是 firewalld 提供的一种灵活且强大的防火墙规则配置方式。与简单的端口和服务规则不同,富规则支持更复杂的匹配条件和操作。</p><p>使用富规则,可以实现复杂的防火墙策略,例如:</p><ul><li>允许特定 IP 地址访问某个端口</li><li>拒绝特定 IP 地址访问某个服务</li><li>限制某个网段的连接频率</li><li>转发某个端口到另一个端口</li></ul><p>富规则的配置方法：<br>firewall-cmd –permanent –add-rich-rule&#x3D;’<rich_rule_definition>‘</p><p>需要注意的是,富规则的语法比较复杂,使用时务必仔细检查,以免引入安全隐患。同时,在修改完成后记得执行 firewall-cmd –reload 命令,让更改生效</p><p>其中rule部分的语法如下：<br>rule [family&#x3D;”<family>“] [source address&#x3D;”<address>“][source port&#x3D;”<port>“] [destination address&#x3D;”<address>“][destination port&#x3D;”<port>“] [protocol value&#x3D;”<protocol>“] [icmp-block-inversion][forward-port port&#x3D;”<port>“ protocol&#x3D;”<protocol>“ to-port&#x3D;”<port>“][masquerade][log [prefix&#x3D;”<prefix>“] [level&#x3D;”<level>“] [limit value&#x3D;”<value>“] [accept][reject][drop]</p><p>其中各个选项的含义如下:</p><ul><li>family: 指定地址族,可以是 ipv4 或 ipv6</li><li>source&#x2F;destination: 指定源&#x2F;目标地址</li><li>port: 指定端口号</li><li>protocol: 指定协议,如 tcp、udp 等</li><li>icmp-block-inversion: 反转 ICMP 阻止规则</li><li>forward-port: 端口转发规则</li><li>masquerade: 启用地址伪装</li><li>log: 日志记录规则,可指定前缀、日志级别、限速</li><li>accept&#x2F;reject&#x2F;drop: 动作,分别表示允许、拒绝、丢弃<br>由于firewalld中的富规则比较复杂，我们从以下几个案例中来简单学习富规则的一些用法即可</li></ul><p>注意：富规则的语法比较复杂,但是可以让您更精细地控制防火墙规则。通过组合不同的条件,您可以实现更复杂的防火墙策略。使用富规则时,请务必仔细检查语法和规则是否符合您的需求,以免引入安全隐患</p><h1 id="服务访问控制-TCP-Wrappers"><a href="#服务访问控制-TCP-Wrappers" class="headerlink" title="服务访问控制 TCP Wrappers"></a>服务访问控制 TCP Wrappers</h1><p>TCP Wrappers是一种用于网络服务访问控制的工具，它使用配置文件中的规则来决定是否允许或拒绝对特定网络服务的访问。控制列表由两个主要文件组成：&#x2F;etc&#x2F;hosts.allow和&#x2F;etc&#x2F;hosts.deny。这些文件包含服务和客户端的规则，用于控制服务的访问权限</p><p>TCP Wrapperes在最新的RockyLinux 9系统中默认已经不适用。通过上述讲到的iptables和firewalld来进行服务访问控制即可。</p><p>TCP Wrappers服务的控制列表文件中常用的参数</p><table><thead><tr><th>客户端类型</th><th>示例</th><th>满足示例的客户端列表</th></tr></thead><tbody><tr><td>单一主机</td><td>192.168.10.10</td><td>IP地址为192.168.10.10的主机</td></tr><tr><td>指定网段</td><td>192.168.10.</td><td>IP段为192.168.10.0&#x2F;24的主机</td></tr><tr><td>指定网段</td><td>192.168.10.0&#x2F;255.255.255.0</td><td>IP段为192.168.10.0&#x2F;24的主机</td></tr><tr><td>指定主机名称</td><td><a href="http://www.eagleslab.com/">www.eagleslab.com</a></td><td>主机名称为<a href="http://www.eagleslab.com的主机/">www.eagleslab.com的主机</a></td></tr><tr><td>指定所有客户端</td><td>ALL，*</td><td>所有主机全部包括在内</td></tr></tbody></table><p>在配置TCP Wrappers服务时需要遵循两个原则：</p><ul><li>编写拒绝策略规则时，填写的是服务名称，而非协议名称；</li><li>建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。</li></ul><p>&#x2F;etc&#x2F;hosts.deny：该文件包含拒绝访问网络服务的规则。如果没有在hosts.allow文件中找到允许访问的规则，TCP Wrappers将检查hosts.deny文件以确定是否拒绝访问。以下规则拒绝所有客户端访问SSH服务：<br>&#x2F;etc&#x2F;hosts.allow：该文件包含允许访问网络服务的规则。每个规则占据一行，有两个主要部分：服务和允许访问的客户端。例如，以下规则允许192.168.88.0&#x2F;24网段访问SSH服务：</p><h1 id="SELinux安全子系统"><a href="#SELinux安全子系统" class="headerlink" title="SELinux安全子系统"></a>SELinux安全子系统</h1><p>SELinux 是一个强大的访问控制机制,它建立在 Linux 内核之上,为系统提供了更细粒度的安全策略控制。与传统的基于用户&#x2F;组的访问控制不同,SELinux 采用基于角色(role)和类型(type)的强制访问控制(Mandatory Access Control, MAC)。简单来讲，SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）</p><p>SELinux 的主要特点包括:</p><ul><li>基于策略的安全访问控制:SELinux 通过预先定义的安全策略来控制系统进程和资源的访问权限,而不是依赖于用户&#x2F;组的身份</li><li>最小特权原则:SELinux 遵循”最小特权”的安全原则,即只授予程序运行所需的最小权限,大大降低了系统被攻击者利用的风险</li><li>灵活的策略配置:SELinux 提供了丰富的策略配置选项,可以根据系统的具体需求进行定制和调整</li><li>审计能力:SELinux 内置了强大的审计日志记录功能,可以帮助管理员快速发现和分析系统安全事件</li></ul><p>SELinux 的主要工作模式包括:</p><ul><li>Enforcing 模式:完全执行 SELinux 策略,阻止任何未经授权的访问行为</li><li>Permissive 模式:只记录违反 SELinux 策略的行为,但不会阻止它们</li><li>Disabled 模式:完全关闭 SELinux 功能</li></ul><h2 id="调整SELinux的模式"><a href="#调整SELinux的模式" class="headerlink" title="调整SELinux的模式"></a>调整SELinux的模式</h2><p>临时调整：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前SELinux的模式</span><br>[root@localhost ~]# getenforce<br>Enforcing<br><br><span class="hljs-comment"># 临时调整为Permissive</span><br>[root@localhost ~]# setenforce 0<br>[root@localhost ~]# getenforce<br>Permissive<br>[0]为Permissive模式，只记录行为，不阻止<br>[1]为Enforcing模式<br></code></pre></td></tr></table></figure><p>临时调整只在当前状态有效，如果系统重启，将会恢复为默认的Enforcing模式</p><p>永久调整：<br>通过编辑配置文件&#x2F;etc&#x2F;selinux&#x2F;config中的SELINUX字段来更改SELinux的模式</p><h2 id="自主访问控制（DAC）"><a href="#自主访问控制（DAC）" class="headerlink" title="自主访问控制（DAC）"></a>自主访问控制（DAC）</h2><p>在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：某个资源是否拥有对应用户的权限（读、写、执行）<br>只要访问这个资源的进程符合以上的条件就可以被访问<br>而最致命问题是，root 用户不受任何管制，系统上任何资源都可以无限制地访问<br>这种权限管理机制的主体是用户，也称为自主访问控制（DAC）</p><h2 id="强制访问控制（MAC）"><a href="#强制访问控制（MAC）" class="headerlink" title="强制访问控制（MAC）"></a>强制访问控制（MAC）</h2><p>在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限<br>这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小<br>即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内。安全性大大增加<br>这种权限管理机制的主体是进程，也称为强制访问控制（MAC）</p><h2 id="semanage-选项-文件"><a href="#semanage-选项-文件" class="headerlink" title="semanage [选项] [文件]"></a>semanage [选项] [文件]</h2><p>基本选项：</p><ul><li>-l：参数用于查询；</li><li>-a：参数用于添加；</li><li>-m：参数用于修改；</li><li>-d：参数用于删除。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁盘管理</title>
    <link href="/2025/10/23/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <url>/2025/10/23/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h1><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><ul><li>管理的硬盘大小不能超过2T</li><li>有主分区和扩展分区两种，不管是哪种分区，总数不能超过4个分区</li><li>扩展分区内部可以逻辑上划分多个区域，但是在分区表中都算在一个分区内</li><li>如果作为系统盘，必须要设置一个激活分区，用于存放系统的引导文件</li></ul><h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><ul><li>管理硬盘大小不能超过18EB，目前人类还没制造出单块这么大的硬盘</li><li>理论上支持无限分区，在win10系统上，最多可以分128个分区</li><li>如果作为系统盘，必须要创建一个EFI分区，用于存放系统的引导文件建议ESP分区512M，对齐8扇区4096字节</li></ul><p>电脑启动的时候：<br>MBR分区表会找到激活分区，从里面加载系统启动；<br>GPT分区表会查找EFI分区，没有是开不了机的，所以GPT分区表情况下需要建立ESP，MSR分区。<br>MSR是微软保留的引导分区，分区一般不会坏因此一般不需要。<br>ESP建立512MB，对齐到扇区整数倍是指一次读写几个扇区（例如新建个txt只写一个字符，依旧占用4K，除非越写越大超过4K，占4K的整数倍），并不是越大越好也不是越小越好，根据实际需求，一般是4KB。</p><h1 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h1><ul><li><p>lsblk 查看磁盘情况</p></li><li><p>创建分区命令<br>– fdisk  管理MBR分区<br>– gdisk  管理GPT分区<br>– parted 高级分区操作</p></li><li><p>partprobe：重新设置内存中的内核分区表版本，在管理分区的命令没有生效的全的情况下，可以执行此命令，重新刷新一下，重新加载分区</p></li></ul><h2 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h2><ul><li><p>parted的操作都是实时生效的，小心使用</p></li><li><p>格式：parted [选项]… [设备 [命令 [参数]…]…]</p></li><li><p>操作命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> [FROM-DEVICE] FROM-MINOR TO-MINOR           <span class="hljs-comment">#将文件系统复制到另一个分区 </span><br><span class="hljs-built_in">help</span> [COMMAND]                                 <span class="hljs-comment">#打印通用求助信息，或关于 COMMAND 的信息 </span><br>mklabel 标签类型                               <span class="hljs-comment">#创建新的磁盘标签 (分区表) </span><br>mkfs MINOR 文件系统类型                        <span class="hljs-comment">#在 MINOR 创建类型为“文件系统类型”的文件系统 </span><br>mkpart 分区类型 [文件系统类型] 起始点 终止点   <span class="hljs-comment">#创建一个分区 </span><br>mkpartfs 分区类型 文件系统类型 起始点 终止点   <span class="hljs-comment">#创建一个带有文件系统的分区 </span><br>move MINOR 起始点 终止点                       <span class="hljs-comment">#移动编号为 MINOR 的分区 </span><br>name MINOR 名称                                <span class="hljs-comment">#将编号为 MINOR 的分区命名为“名称” </span><br><span class="hljs-built_in">print</span> [MINOR]                                  <span class="hljs-comment">#打印分区表，或者分区 </span><br>quit                                           <span class="hljs-comment">#退出程序 </span><br>rescue 起始点 终止点                           <span class="hljs-comment">#挽救临近“起始点”、“终止点”的遗失的分区 </span><br>resize MINOR 起始点 终止点                     <span class="hljs-comment">#改变位于编号为 MINOR 的分区中文件系统的大小 </span><br><span class="hljs-built_in">rm</span> MINOR                                       <span class="hljs-comment">#删除编号为 MINOR 的分区 </span><br><span class="hljs-keyword">select</span> 设备                                    <span class="hljs-comment">#选择要编辑的设备 </span><br><span class="hljs-built_in">set</span> MINOR 标志 状态                            <span class="hljs-comment">#改变编号为 MINOR 的分区的标志</span><br></code></pre></td></tr></table></figure><ul><li>查看分区情况</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">parted /dev/nvme0n1 <span class="hljs-built_in">print</span><br></code></pre></td></tr></table></figure><ul><li>设置磁盘的分区表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# parted /dev/nvme0n2 mklabel gpt/msdos<br></code></pre></td></tr></table></figure><ul><li>对磁盘进行分区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# parted /dev/nvme0n2 mkpart primary 1 1G<br></code></pre></td></tr></table></figure><ul><li>删除分区</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# parted /dev/nvme0n2 <span class="hljs-built_in">rm</span> 1<br></code></pre></td></tr></table></figure><ul><li>修改磁盘为mbr分区，注意会丢失所有数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# parted /dev/nvme0n2 mklabel msdos<br>警告: The existing disk label on /dev/nvme0n2 will be destroyed and all data on this disk will be lost. Do<br>you want to <span class="hljs-built_in">continue</span>?<br>是/Yes/否/No? <span class="hljs-built_in">yes</span><br>信息: You may need to update /etc/fstab.<br></code></pre></td></tr></table></figure><h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><p>管理磁盘中MBR分区<br>fdisk [磁盘名称] ：指定要操作的磁盘名称,进入一个交互式的页面</p><p>fdisk命令中的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>m</td><td>查看全部可用的参数</td></tr><tr><td>n</td><td>添加新的分区</td></tr><tr><td>d</td><td>删除某个分区信息</td></tr><tr><td>l</td><td>列出所有可用的分区类型</td></tr><tr><td>t</td><td>改变某个分区的类型</td></tr><tr><td>p</td><td>查看分区信息</td></tr><tr><td>w</td><td>保存并退出</td></tr><tr><td>q</td><td>不保存直接退出</td></tr></tbody></table><h2 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h2><p>管理磁盘中的GPT分区<br>使用方式和选项与fdisk中几乎一致</p><h1 id="磁盘结构与磁盘划分"><a href="#磁盘结构与磁盘划分" class="headerlink" title="磁盘结构与磁盘划分"></a>磁盘结构与磁盘划分</h1><p>Linux系统中常见的目录名称以及相应内容</p><table><thead><tr><th>目录名称</th><th>应放置文件的内容</th></tr></thead><tbody><tr><td>&#x2F;boot</td><td>开机所需文件—内核、开机菜单以及所需配置文件等</td></tr><tr><td>&#x2F;dev</td><td>以文件形式存放任何设备与接口</td></tr><tr><td>&#x2F;etc</td><td>配置文件</td></tr><tr><td>&#x2F;home</td><td>用户家目录</td></tr><tr><td>&#x2F;bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>&#x2F;lib</td><td>开机时用到的函数库，以及&#x2F;bin与&#x2F;sbin下面的命令要调用的函数</td></tr><tr><td>&#x2F;sbin</td><td>开机过程中需要的命令</td></tr><tr><td>&#x2F;media</td><td>用于挂载设备文件的目录</td></tr><tr><td>&#x2F;opt</td><td>放置第三方的软件</td></tr><tr><td>&#x2F;root</td><td>系统管理员的家目录</td></tr><tr><td>&#x2F;srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>&#x2F;tmp</td><td>任何人均可使用的“共享”临时目录</td></tr><tr><td>&#x2F;proc</td><td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td>&#x2F;usr&#x2F;local</td><td>用户自行安装的软件</td></tr><tr><td>&#x2F;usr&#x2F;sbin</td><td>Linux系统开机时不会使用到的软件&#x2F;命令&#x2F;脚本</td></tr><tr><td>&#x2F;usr&#x2F;share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>&#x2F;var</td><td>主要存放经常变化的文件，如日志文件、数据文件</td></tr><tr><td>&#x2F;lost+found</td><td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table><p>表示路径的方式：<br>绝对路径指的是从根目录（&#x2F;）开始写起的文件或目录名称<br>相对路径则指的是相对于当前路径的写法</p><h1 id="物理设备的命令规则"><a href="#物理设备的命令规则" class="headerlink" title="物理设备的命令规则"></a>物理设备的命令规则</h1><p>常见的硬件设备及其文件名称</p><table><thead><tr><th>硬件设备</th><th>文件名称</th></tr></thead><tbody><tr><td>IDE设备</td><td>&#x2F;dev&#x2F;hd[a-d]</td></tr><tr><td>SCSI&#x2F;SATA&#x2F;U盘</td><td>&#x2F;dev&#x2F;sd[a-p]</td></tr><tr><td>软驱</td><td>&#x2F;dev&#x2F;fd[0-1]</td></tr><tr><td>打印机</td><td>&#x2F;dev&#x2F;lp[0-15]</td></tr><tr><td>光驱</td><td>&#x2F;dev&#x2F;cdrom</td></tr><tr><td>鼠标</td><td>&#x2F;dev&#x2F;mouse</td></tr><tr><td>磁带机</td><td>&#x2F;dev&#x2F;st0或&#x2F;dev&#x2F;ht0</td></tr></tbody></table><h1 id="文件系统与数据资料"><a href="#文件系统与数据资料" class="headerlink" title="文件系统与数据资料"></a>文件系统与数据资料</h1><p>当我们对一块硬盘分区好了以后，接下来我们还要做一件事情，就是我们要对这个分区做一个规定。也可以理解为，当我们要在这个分区上面存放数据的时候，应该按照什么样的规律存放，或者是读取的时候，应该按照什么样的规律读取。</p><p>这样对磁盘或者分区的规定，我们就称之为文件系统。</p><p>文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。Linux系统支持数十种的文件系统。但是从大的角度上来看，其实主要分为日志式文件系统和索引式文件系统两种。</p><h2 id="日志式文件系统"><a href="#日志式文件系统" class="headerlink" title="日志式文件系统"></a>日志式文件系统</h2><p>通过inode表获取存储的位置，常见的日志式文件系统有ext4、xfs、ntfs等等。</p><h2 id="索引式文件系统"><a href="#索引式文件系统" class="headerlink" title="索引式文件系统"></a>索引式文件系统</h2><p>通过索引表获取存储的位置，常见的索引式文件系统有fat12、fat16、fat32等等。</p><h2 id="格式化后发生的事情"><a href="#格式化后发生的事情" class="headerlink" title="格式化后发生的事情"></a>格式化后发生的事情</h2><ul><li>日志式文件系统先干掉inode表，索引式文件系统先干掉第一个索引，表示空间可用。</li><li>Linux创建一个硬盘地图’superblock’，记录此filesystem 的整体信息，包括inode&#x2F;block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；</li></ul><p>– inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block 号码，默认一个inode表格128字节，一个block记录消耗4B，记录满了后会新建inode用于扩展。<br>— 该文件的访问权限（read、write、execute）；<br>— 该文件的所有者与所属组（owner、group）；<br>— 该文件的大小（size）；<br>— 该文件的创建或内容修改时间（ctime）；<br>— 该文件的最后一次访问时间（atime）；<br>— 该文件的修改时间（mtime）；<br>— 文件的特殊权限（SUID、SGID、SBIT）；<br>— 该文件的真实数据地址（point）。<br>– block：用于存储数据</p><h2 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h2><p>Linux mkfs（英文全拼：make file system）命令用于在特定的分区上建立 linux 文件系统。<br>mkfs<br>[-V] [-t fstype] [fs-options] filesys [blocks]</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>device ： 预备检查的硬盘分区，例如：&#x2F;dev&#x2F;nvme0n1p1</li><li>-V : 详细显示模式</li><li>-c : 在制做档案系统前，检查该partition 是否有坏轨</li><li>-l bad_blocks_file : 将有坏轨的block资料加到 bad_blocks_file 里面</li><li>block : 给定 block 的大小</li></ul><h2 id="mount挂载"><a href="#mount挂载" class="headerlink" title="mount挂载"></a>mount挂载</h2><p>挂载文件系统mount 文件系统 挂载目录</p><p>mount命令中的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-a</td><td>挂载所有在&#x2F;etc&#x2F;fstab中定义的文件系统</td></tr><tr><td>-t</td><td>指定文件系统的类型</td></tr></tbody></table><p>临时挂载文件系统<br>系统在重启后挂载就会失效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node-1 ~]# <span class="hljs-built_in">mkdir</span> backup<br>[root@node-1 ~]# mount /dev/sda2 /root/backup<br></code></pre></td></tr></table></figure><p>如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”,写入到&#x2F;etc&#x2F;fstab文件中。<br>用于挂载信息的指定填写格式中，各字段所表示的意义:</p><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>设备文件</td><td>一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）</td></tr><tr><td>挂载目录</td><td>指定要挂载到的目录，需在挂载前创建好</td></tr><tr><td>格式类型</td><td>指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</td></tr><tr><td>权限选项</td><td>若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</td></tr><tr><td>是否备份</td><td>若为1则开机后使用dump进行磁盘备份，为0则不备份</td></tr><tr><td>是否自检</td><td>若为1则开机后自动进行磁盘自检，为0则不自检</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">mkdir</span> -p /mnt/volume1<br>[root@localhost ~]# mount /dev/sdb1 /mnt/volume1<br>[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>文件系统                 容量  已用  可用 已用% 挂载点<br>/dev/mapper/centos-root   47G  995M   46G    3% /<br>devtmpfs                 979M     0  979M    0% /dev<br>tmpfs                    991M     0  991M    0% /dev/shm<br>tmpfs                    991M  8.5M  982M    1% /run<br>tmpfs                    991M     0  991M    0% /sys/fs/cgroup<br>/dev/sda1               1014M  133M  882M   14% /boot<br>tmpfs                    199M     0  199M    0% /run/user/0<br>/dev/sdb1                9.1G   37M  8.6G    1% /mnt/volume1<br><span class="hljs-comment"># 先卸载sdb1</span><br>[root@localhost ~]# umount /dev/sdb1<br>[root@localhost ~]# vim /etc/fstab<br><span class="hljs-comment"># 最后一行加上</span><br>/dev/sdb1 /mnt/volume1 ext4 defaults 0 0<br><br>[root@localhost ~]# mount -a<br><span class="hljs-comment"># 测试是否正确配置，fstab上的设备挂一遍试试看，万一错了重启系统会失败。</span><br>[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>文件系统                 容量  已用  可用 已用% 挂载点<br>/dev/mapper/centos-root   47G  995M   46G    3% /<br>devtmpfs                 979M     0  979M    0% /dev<br>tmpfs                    991M     0  991M    0% /dev/shm<br>tmpfs                    991M  8.5M  982M    1% /run<br>tmpfs                    991M     0  991M    0% /sys/fs/cgroup<br>/dev/sda1               1014M  133M  882M   14% /boot<br>tmpfs                    199M     0  199M    0% /run/user/0<br>/dev/sdb1                9.1G   37M  8.6G    1% /mnt/volume1<br></code></pre></td></tr></table></figure><h2 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h2><p>撤销已经挂载的设备文件umount [挂载点&#x2F;设备文件]</p><p>挂载实验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进行了格式化后</span><br><span class="hljs-comment">#[root@localhost ~]# mkfs.ext4 /dev/sdb1</span><br><span class="hljs-comment">#未挂载sdb1前，此时file0创建在sda1上</span><br>[root@localhost ~]# <span class="hljs-built_in">mkdir</span> /mnt/disk1<br>[root@localhost ~]# <span class="hljs-built_in">touch</span> /mnt/disk1/file0<br>[root@localhost ~]# ll /mnt/disk1/<br>-rw-r--r--  1 root root 0 6月   9 19:44 file0<br><span class="hljs-comment">#挂载sdb1,file0消失</span><br>[root@localhost ~]# mount /dev/sdb1 /mnt/disk1/<br>[root@localhost ~]# ll /mnt/disk1/<br>drwx------ 2 root root 16384 6月   9 19:42 lost+found<br><span class="hljs-comment">#此时file0创建在sda1</span><br>[root@localhost ~]# <span class="hljs-built_in">touch</span> /mnt/disk1/file1<br>[root@localhost ~]# ll /mnt/disk1/<br>-rw-r--r-- 1 root root     0 6月   9 19:48 file1<br>drwx------ 2 root root 16384 6月   9 19:42 lost+found<br><span class="hljs-comment">#卸载sdb1,file1消失，file0出现</span><br>[root@localhost ~]# umount /dev/sdb1<br>[root@localhost ~]# ll /mnt/disk1/<br>-rw-r--r--  1 root root 0 6月   9 19:44 file0<br></code></pre></td></tr></table></figure><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>用于显示文件系统的磁盘空间使用情况</p><p>常用选项</p><ul><li>-h：以人类可读的格式显示磁盘空间，使用K、M、G等单位。</li><li>-T：显示文件系统类型。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">df</span> -h<br>文件系统                 容量  已用  可用 已用% 挂载点<br>/dev/mapper/centos-root   47G  995M   46G    3% /<br>devtmpfs                 979M     0  979M    0% /dev<br>tmpfs                    991M     0  991M    0% /dev/shm<br>tmpfs                    991M  8.5M  982M    1% /run<br>tmpfs                    991M     0  991M    0% /sys/fs/cgroup<br>/dev/sda1               1014M  133M  882M   14% /boot<br>tmpfs                    199M     0  199M    0% /run/user/0<br>/dev/sdb1                9.1G   37M  8.6G    1% /mnt/volume1<br></code></pre></td></tr></table></figure><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>查看某个目录下文件数据的占用量</p><p>du [选项] [文件]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">du</span> -sh /etc<br>23M     /etc<br></code></pre></td></tr></table></figure><h2 id="添加交换分区"><a href="#添加交换分区" class="headerlink" title="添加交换分区"></a>添加交换分区</h2><p>SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术</p><p>在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# mkswap /dev/nvme0n2p1<br>Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)<br>no label, UUID=9d5158b3-9a30-4a0a-8167-7ee1bc9ce4f8<br>[root@localhost ~]# free -h<br>               total        used        free      shared  buff/cache   available<br>Mem:           1.7Gi       448Mi       1.2Gi       6.0Mi       201Mi       1.3Gi<br>Swap:          2.0Gi          0B       2.0Gi<br>[root@localhost ~]# swapon /dev/nvme0n2p1        <span class="hljs-comment"># 挂载swap交换分区</span><br>[root@localhost ~]# vim /etc/fstab                <span class="hljs-comment"># 写入fstab文件中永久挂载</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># /etc/fstab</span><br><span class="hljs-comment"># Created by anaconda on Sat Nov  9 02:51:16 2024</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk/&#x27;.</span><br><span class="hljs-comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># After editing this file, run &#x27;systemctl daemon-reload&#x27; to update systemd</span><br><span class="hljs-comment"># units generated from this file.</span><br><span class="hljs-comment">#</span><br>/dev/mapper/rl-root     /                       xfs     defaults        0 0<br>UUID=12fcea99-d1db-4f0a-ad86-f03129024fdb /boot                   xfs     defaults        0 0<br>/dev/mapper/rl-swap     none                    swap    defaults        0 0<br>/dev/nvme0n2p1          swap                    swap    defaults        0 0<br><br>[root@localhost ~]# free -h<br>               total        used        free      shared  buff/cache   available<br>Mem:           1.7Gi       451Mi       1.2Gi       6.0Mi       205Mi       1.3Gi<br>Swap:          3.0Gi          0B       3.0Gi<br></code></pre></td></tr></table></figure><h1 id="磁盘容量配额"><a href="#磁盘容量配额" class="headerlink" title="磁盘容量配额"></a>磁盘容量配额</h1><p>简单理解就是可以通过磁盘配额限制某个用户能够使用多大的空间</p><h2 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h2><h3 id="确保文件系统支持"><a href="#确保文件系统支持" class="headerlink" title="确保文件系统支持"></a>确保文件系统支持</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#检查挂载点是否支持quota配置</span><br>[root@localhost ~]# mount | grep mountpoint<br>/dev/nvme0n2p1 on /mnt/mountpoint <span class="hljs-built_in">type</span> ext4 (rw,relatime,seclabel)<br><span class="hljs-comment">#重新挂载，让文件系统支持quota配置</span><br>[root@localhost ~]# mount -o remount,usrquota,grpquota /mnt/mountpoint/<br>[root@localhost ~]# mount | grep mountpoint<br>/dev/nvme0n2p1 on /mnt/mountpoint <span class="hljs-built_in">type</span> ext4 (rw,relatime,seclabel,quota,usrquota,grpquota)<br></code></pre></td></tr></table></figure><h3 id="安装-quota"><a href="#安装-quota" class="headerlink" title="安装 quota"></a>安装 quota</h3><p>[root@atopos ~]# yum install -y quota</p><ul><li>软限制：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。</li><li>硬限制：当达到硬限制时会提示用户，且强制终止用户的操作。</li></ul><p>quotacheck主要参数</p><ul><li>-a：扫描所有在&#x2F;etc&#x2F;mtab内含有quota参数的文件系统</li><li>-u：针对用户扫描文件与目录的使用情况，会新建一个aquota.user文件</li><li>-g：针对用户组扫描文件与目录的使用情况，会新增一个aquota.group文件</li><li>-v：显示扫描过程的信息</li></ul><h3 id="开启-quota"><a href="#开启-quota" class="headerlink" title="开启 quota"></a>开启 quota</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# quotacheck -avug<br>quotacheck: Your kernel probably supports ext4 quota feature but you are using external quota files. Please switch your filesystem to use ext4 quota feature as external quota files on ext4 are deprecated.<br>quotacheck: Scanning /dev/nvme0n2p1 [/mnt/mountpoint] <span class="hljs-keyword">done</span><br>quotacheck: Cannot <span class="hljs-built_in">stat</span> old user quota file /mnt/mountpoint/aquota.user: No such file or directory. Usage will not be subtracted.<br>quotacheck: Cannot <span class="hljs-built_in">stat</span> old group quota file /mnt/mountpoint/aquota.group: No such file or directory. Usage will not be subtracted.<br>quotacheck: Cannot <span class="hljs-built_in">stat</span> old user quota file /mnt/mountpoint/aquota.user: No such file or directory. Usage will not be subtracted.<br>quotacheck: Cannot <span class="hljs-built_in">stat</span> old group quota file /mnt/mountpoint/aquota.group: No such file or directory. Usage will not be subtracted.<br>quotacheck: Checked 8 directories and 15 files<br>quotacheck: Old file not found.<br>quotacheck: Old file not found.<br>[root@localhost ~]# quotaon -avug<br>quotaon: Your kernel probably supports ext4 quota feature but you are using external quota files. Please switch your filesystem to use ext4 quota feature as external quota files on ext4 are deprecated.<br>/dev/nvme0n2p1 [/mnt/mountpoint]: group quotas turned on<br>/dev/nvme0n2p1 [/mnt/mountpoint]: user quotas turned on<br></code></pre></td></tr></table></figure><h3 id="编辑配额配置"><a href="#编辑配额配置" class="headerlink" title="编辑配额配置"></a>编辑配额配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# edquota -u user1<br><span class="hljs-comment">#可以将针对user1的限制复制给user2</span><br>[root@localhost ~]# edquota -p user1 -u user2<br><span class="hljs-comment">#查看限制情况</span><br>[root@localhost ~]# repquota -as<br>*** Report <span class="hljs-keyword">for</span> user quotas on device /dev/nvme0n2p1<br>Block grace <span class="hljs-keyword">time</span>: 7days; Inode grace <span class="hljs-keyword">time</span>: 7days<br>                        Space limits                File limits<br>User            used    soft    hard  grace    used  soft  hard  grace<br>----------------------------------------------------------------------<br>root      --     20K      0K      0K              2     0     0<br>user1     --     16K    245M    293M              4     0     0<br>user2     --     16K    245M    293M              4     0     0<br>user3     --     16K      0K      0K              4     0     0<br>user4     --     16K      0K      0K              4     0     0<br>user5     --     16K      0K      0K   <br></code></pre></td></tr></table></figure><pre><code class="hljs">       4     0     0</code></pre><p>blocks：当前用户&#x2F;组使用的磁盘空间（以1KB为单位，或者取决于文件系统的块大小）。此字段是只读的，由系统直接计算，无需手动修改。<br>soft：磁盘空间的软限制。用户&#x2F;组可以临时超过此限制，但必须在宽限期内（默认为7天）将使用率下降到软限制以下，否则会被禁止进一步使用空间。<br>hard：磁盘空间的硬限制。用户&#x2F;绝对不能超过此限制，尝试超过时会报错。<br>inodes：当前用户&#x2F;组使用的文件&#x2F;目录数。此字段是只读的，由系统直接计算，无需手动修改。<br>soft：文件数软限制。用户&#x2F;组可以临时超过此限制，但必须在宽限期内减少文件数量。<br>hard：文件数硬限制。用户&#x2F;组不能超过此限制，尝试超过时会报错。<br>如果某个字段设置为0表示没有磁盘限制</p><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># user1用户测试</span><br>[root@localhost ~]# su - user1<br>[user1@localhost ~]$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=bigfile bs=10M count=50<br>nvme0n2p1: warning, user block quota exceeded.<br>nvme0n2p1: write failed, user block <span class="hljs-built_in">limit</span> reached.<br><span class="hljs-built_in">dd</span>: error writing <span class="hljs-string">&#x27;bigfile&#x27;</span>: Disk quota exceeded<br>30+0 records <span class="hljs-keyword">in</span><br>29+0 records out<br>307179520 bytes (307 MB, 293 MiB) copied, 1.1834 s, 260 MB/s<br>[user1@localhost ~]$ <span class="hljs-built_in">du</span> -sh<br>293M    .<br><br><span class="hljs-comment"># user2用户测试</span><br>[root@localhost ~]# su - user2<br>[user2@localhost ~]$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=bigfile bs=10M count=50<br>nvme0n2p1: warning, user block quota exceeded.<br>nvme0n2p1: write failed, user block <span class="hljs-built_in">limit</span> reached.<br><span class="hljs-built_in">dd</span>: error writing <span class="hljs-string">&#x27;bigfile&#x27;</span>: Disk quota exceeded<br>30+0 records <span class="hljs-keyword">in</span><br>29+0 records out<br>307183616 bytes (307 MB, 293 MiB) copied, 1.43269 s, 214 MB/s<br>[user2@localhost ~]$ <span class="hljs-built_in">du</span> -sh<br>293M    .<br></code></pre></td></tr></table></figure><h3 id="quota-命令"><a href="#quota-命令" class="headerlink" title="quota 命令"></a>quota 命令</h3><p>Linux quota命令用于显示磁盘已使用的空间与限制。<br>执行quota指令，可查询磁盘空间的限制，并得知已使用多少空间</p><p>选项：</p><ul><li>-g 列出群组的磁盘空间限制。</li><li>-q 简明列表，只列出超过限制的部分。</li><li>-u 列出用户的磁盘空间限制。</li><li>-v 显示该用户或群组，在所有挂入系统的存储设备的空间限制。</li><li>-V 显示版本信息。</li></ul><h2 id="xfs-quota"><a href="#xfs-quota" class="headerlink" title="xfs_quota"></a>xfs_quota</h2><p>专门针对XFS文件系统来管理quota磁盘容量配额服务</p><p>xfs_quota [参数] 配额 文件系统</p><ul><li>-c参数用于以参数的形式设置要执行的命令</li><li>-x参数是专家模式</li></ul><h1 id="软硬方式链接"><a href="#软硬方式链接" class="headerlink" title="软硬方式链接"></a>软硬方式链接</h1><p>在Linux系统中存在硬链接和软连接两种文件。</p><ul><li>硬链接（hard link）：<br>可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。</li><li>软链接（也称为符号链接[symbolic link]）：<br>仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。<br>软链接文件和硬链接文件的区别是：</li><li>当原文件发生修改时，软连接文件和硬连接文件都会被修改。</li><li>当软连接文件和硬链接文件发生修改时，原文件也会被修改。</li><li>当软连接文件和硬链接文件被删除时，原文件不受影响。</li><li>原文件删除时，软连接失效，硬链接正常使用。</li><li>软链接文件可以跨分区跨文件系统创建，硬链接文件不可以。</li></ul><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><p>用于创建链接文件</p><p>ln [选项] 目标</p><p>ln命令中可用的参数以及作用</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-s</td><td>创建“符号链接”（如果不带-s参数，则默认创建硬链接）</td></tr><tr><td>-f</td><td>强制创建文件或目录的链接</td></tr><tr><td>-i</td><td>覆盖前先询问</td></tr><tr><td>-v</td><td>显示创建链接的过程</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello linux&quot;</span> &gt; testfile<br>[root@localhost ~]# <span class="hljs-built_in">ln</span> -s testfile linkfile            <span class="hljs-comment"># 创建软连接</span><br>[root@localhost ~]# ll<br>total 8<br>-rw-------. 1 root root 905 Nov  9 10:57 anaconda-ks.cfg<br>lrwxrwxrwx. 1 root root   8 Nov 15 20:41 linkfile -&gt; testfile<br>-rw-r--r--. 1 root root  12 Nov 15 20:40 testfile<br>[root@localhost ~]# <span class="hljs-built_in">cat</span> linkfile<br>hello linux<br>[root@localhost ~]# <span class="hljs-built_in">ls</span> -l linkfile<br>lrwxrwxrwx. 1 root root 8 Nov 15 20:41 linkfile -&gt; testfile<br>[root@localhost ~]# <span class="hljs-built_in">rm</span> -f testfile<br>[root@localhost ~]# <span class="hljs-built_in">cat</span> linkfile<br><span class="hljs-built_in">cat</span>: linkfile: No such file or directory<br>硬链接演示<br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello linux&quot;</span> &gt; testfile<br>[root@localhost ~]# <span class="hljs-built_in">ln</span> testfile linkfile<br>[root@localhost ~]# <span class="hljs-built_in">cat</span> linkfile<br>hello linux<br>[root@localhost ~]# <span class="hljs-built_in">ls</span> -l linkfile<br>-rw-r--r--. 2 root root 12 Nov 15 20:42 linkfile<br>[root@localhost ~]# <span class="hljs-built_in">rm</span> -f testfile<br>[root@localhost ~]# <span class="hljs-built_in">cat</span> linkfile<br>hello linux<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件权限管理</title>
    <link href="/2025/10/21/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/2025/10/21/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p>用户想要操作一个文件，要先检查文件权限，知道能怎么操作。<br>文件权限分为三类：属主、用户、其他。每一个file都有三个权限：读r、写w、执行x。<br>用ll命令查看<br>-rw——-. 1 root root 817 Sep 24 17:28 anaconda-ks.cfg<br>-rw-r–r–. 1 root root   0 Sep 26 15:32 install.log<br>上面是文件权限的例子每个文件都有0~9十个字符，第一个字符是文件类型，1-3个字符是属主，4-6个字符是用户，7-9个字符是其他。</p><h1 id="修改文件属主chown"><a href="#修改文件属主chown" class="headerlink" title="修改文件属主chown"></a>修改文件属主chown</h1><p>chown用于设置文件所有者和文件关联组的命令即修改属主和数组<br>chown 需要超级用户root的权限才能执行此命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [选项]... [所有者][:[组]] 文件...<br></code></pre></td></tr></table></figure><p>-R: 处理指定目录以及其子目录下的所有文件<br>-v: 显示详细的处理信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置所有者为root</span><br>[root@localhost ~]# <span class="hljs-built_in">chown</span> root anaconda-ks.cfg<br><span class="hljs-comment">#将文件的拥有者设置为user01，允许使用的组设置为it</span><br>[root@localhost ~]# <span class="hljs-built_in">chown</span> user01:it file.txt<br><span class="hljs-comment">#将目录下的所有文件拥有者设置为user01，允许使用的组设置为it</span><br>[root@localhost ~]# <span class="hljs-built_in">chown</span> -R user01:it <span class="hljs-built_in">dir</span>/*<br></code></pre></td></tr></table></figure><h1 id="修改文件权限chmod"><a href="#修改文件权限chmod" class="headerlink" title="修改文件权限chmod"></a>修改文件权限chmod</h1><p>chmod用于修改文件权限的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [选项]... 模式[,模式]... 文件...<br><span class="hljs-built_in">chmod</span> u/g/o/a+/-/= 文件<br></code></pre></td></tr></table></figure><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>mode : 权限设定字串，格式如下 :<br>[ugoa…][[+-&#x3D;][rwx]…][,…]</p><ul><li>u表示该文件的拥有者，g表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a表示这三者皆是。</li><li>+表示增加权限、-表示取消权限、&#x3D;表示唯一设定权限。</li><li>r表示可读取，w表示可写入，x表示可执行<table><thead><tr><th>权限</th><th>对文件的影响</th><th>对目录的影响</th></tr></thead><tbody><tr><td>r(读取)</td><td>可以读取文件的内容</td><td>可以列出目录的内容(文件名)，可以使用ls命令</td></tr><tr><td>w(写入)</td><td>可以更改文件的内容</td><td>可以创建或删除目录中的任一文件，可以使用touch、rm命令</td></tr><tr><td>x(可执行)</td><td>可以作为命令执行文件</td><td>可以访问目录的内容(取决于目录中文件的权限)，可以使用cd命令</td></tr></tbody></table></li></ul><h2 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h2><p>765 将这样解释：</p><ul><li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li><li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li><li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li></ul><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>-f: 若该文件权限无法被更改也不要显示错误讯息<br>-v: 显示权限变更的详细资料<br>-R: 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</p><h1 id="文件访问控制列表"><a href="#文件访问控制列表" class="headerlink" title="文件访问控制列表"></a>文件访问控制列表</h1><p>文件访问控制列表（Access Control Lists，ACL）是Linux开的一套新的文件系统权限管理方法。</p><p>传统的Linux文件系统的权限控制是通过user、group、other与r（读）、w（写）、x（执行）的不同组合来实现的。随着应用的发展，这些权限组合已不能适应现时复杂的文件系统权限控制要求。例如，我们可能需把一个文件的读权限和写权限分别赋予两个不同的用户或一个用户和一个组这样的组合。传统的权限管理设置起来就力不从心了。</p><p>文件访问控制列表可以针对文件单独设置某个用户或者用户组队文件的管理权限。</p><h2 id="getfacl"><a href="#getfacl" class="headerlink" title="getfacl"></a>getfacl</h2><p>获取文件acl的详细内容<br>getfacl [-aceEsRLPtpndvh] file …</p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul><li>-a：仅显示文件访问控制列表</li><li>-d：仅显示默认的访问控制列表</li><li>-c：不显示注释表头</li><li>-e：显示所有的有效权限</li><li>-E：显示无效权限</li><li>-R：递归显示子目录</li><li>-t：使用制表符分隔的输出格式</li></ul><h2 id="setfacl"><a href="#setfacl" class="headerlink" title="setfacl"></a>setfacl</h2><p>用来设置更精确的文件权限<br>setfacl [-bkndRLP] { -m|-M|-x|-X … } file …</p><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul><li>-m：更改文件的访问控制列表</li><li>-M：从文件读取访问控制列表条目更改</li><li>-x：根据文件中访问控制列表移除条目</li><li>-X：从文件读取访问控制列表条目并删除</li><li>-b：删除所有扩展访问控制列表条目</li><li>-k：移除默认访问控制列表</li><li>-d：应用到默认访问控制列表的操作</li><li>-R：递归操作子目录</li></ul><h2 id="mask有效权限"><a href="#mask有效权限" class="headerlink" title="mask有效权限"></a>mask有效权限</h2><p>mask 权限，指的是用户或群组能拥有的最大 ACL 权限，也就是说，给用户或群组设定的 ACL 权限不能超过 mask 规定的权限范围，超出部分做无效处理。</p><h1 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h1><p>文件除了上述的r,w，x权限以外，还有三个特殊权限：suid，sgid，sticky</p><h2 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h2><p>suid 属性只能运用在可执行文件上，含义是开放文件所有者的权限给其他用户，即当用户执行该执行文件时，会拥有该执行文件所有者的权限。如果给一个非二进制文件文件附加suid权限，则会显示大写S，属于无效。</p><p>普通用户能够执行passwd命令修改自己的密码，修改密码其实就是修改&#x2F;etc&#x2F;shadow这个文件，查看&#x2F;usr&#x2F;bin&#x2F;passwd这个文件的权限，发现除了root其他人没有写权限，但是普通用户能够成功执行passwd，其原因就在于passwd这个命令的权限是-rwsr-xr-x，其中s的作用就是让执行命令的人具有和该命令拥有者相同的权限。</p><p>一个普通用户想要修改密码，必须先执行passwd命令，执行命令时，会调用&#x2F;usr&#x2F;bin&#x2F;passwd这个可执行文件，这个文件具有suid属性，执行这个文件时，会调用shadow这个文件，shadow文件的权限是-rw-r—–，只有root用户才能修改这个文件，但是普通用户能够执行这个文件，因为这个文件的权限是-rwsr-xr-x，普通用户能够成功执行这个文件，因为这个文件的权限中s的作用就是让普通用户具有和root相同的权限。</p><p>要设置特殊权限，可以使用chmod命令的4位数字表示法，其中第一位用于特殊权限，后三位分别代表所有者、组和其他用户的权限。特殊权限的设置如下：</p><ul><li><ul><li>4: 设置setuid</li></ul></li><li><ul><li>2: 设置setgid</li></ul></li><li><ul><li>1: 设置sticky bit。</li></ul></li></ul><h2 id="sgid"><a href="#sgid" class="headerlink" title="sgid"></a>sgid</h2><p>sgid 属性可运用于二进制文件或者目录，运用在文件的含义是开放文件所属组的权限给其他用户，即当用户执行该执行文件时，会拥有该执行文件所属组用户的权限。如果给一个非二进制文件文件附加sgid权限，则会显示大写S，属于无效。</p><p>运用在目录上的含义是，在该目录下所有用户创建的文件或者目录的所属组都和其一样。即如果&#x2F;home&#x2F;user1目录具有sgid权限，且所属组是user1，则任何用户在&#x2F;home&#x2F;user1下创建的子目录或者文件的所属组都是user1。</p><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>sticky 权限只能运用于目录上，含义是该目录下所有的文件和子目录只能由所属者删除，即使其的权限是777或者其他。一个公共目录，每个人都可以创建文件，删除自己的文件，但不能删除别人的文件(仅对目录有效)。</p><h2 id="赋权操作"><a href="#赋权操作" class="headerlink" title="赋权操作"></a>赋权操作</h2><p>chmod u+s &#x2F; chmod 4644<br>chmod g+s &#x2F; chmod 2644<br>chmod o+t &#x2F; chmod 1644<br>如果文件本身对应位置有x权限则字母s小写，没有则大写</p><h1 id="chattr文件属性"><a href="#chattr文件属性" class="headerlink" title="chattr文件属性"></a>chattr文件属性</h1><p>chattr命令用于改变文件属性。<br>这项指令可改变存放在文件或目录属性，这些属性共有以下8种模式：</p><ul><li>a：让文件或目录仅供追加用途</li><li>b：不更新文件或目录的最后存取时间</li><li>c：将文件或目录压缩后存放</li><li>i：不得任意更动文件或目录</li><li>s：保密性删除文件或目录</li><li>S：即时更新文件或目录</li><li>u：预防意外删除</li></ul><p>chattr [-RV][+&#x2F;-&#x2F;&#x3D;&lt;属性&gt;][文件或目录…]</p><h2 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h2><ul><li>-R：递归处理，将指定目录下的所有文件及子目录一并处理</li><li>-v &lt;版本编号&gt;：设置文件或目录版本</li><li>-V：显示指令执行过程</li><li><ul><li>&lt;属性&gt;：开启文件或目录的该项属性</li></ul></li><li><ul><li>&lt;属性&gt;：关闭文件或目录的该项属性</li></ul></li><li>&#x3D; &lt;属性&gt;：指定文件或目录的该项属性</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">用chattr命令防止系统中某个关键文件被修改<br>[root@localhost ~]# chattr +i /etc/resolv.conf<br>[root@localhost ~]# lsattr /etc/resolv.conf <br>----i----------- /etc/resolv.conf<br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-built_in">test</span> &gt;&gt; /etc/resolv.conf<br>-bash: /etc/resolv.conf: 权限不够<br><br>让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件<br>[root@localhost ~]# chattr +a /var/log/messages <br>[root@localhost ~]# lsattr /var/log/messages <br>-----a---------- /var/log/messages<br>[root@localhost ~]# <span class="hljs-built_in">echo</span> &gt; /var/log/messages   <span class="hljs-comment"># 不允许清空日志</span><br>-bash: /var/log/messages: 不允许的操作<br></code></pre></td></tr></table></figure><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>umask命令指定在建立文件时预设的权限掩码，进程、新建文件、目录的默认权限会收到umask的影响，umask表示要减掉得到权限。</p><p>umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</p><ul><li>文件最终权限&#x3D;666-umask</li><li>目录最终权限&#x3D;777-umask</li></ul><p>想要让umask的值永久修改就要在&#x2F;etc&#x2F;profile文件中修改</p><p>&#x2F;etc&#x2F;passwd：用户信息文件<br>&#x2F;etc&#x2F;group：用户组信息文件<br>&#x2F;etc&#x2F;shadow：用户密码文件<br>&#x2F;etc&#x2F;gshadow：用户组密码文件<br>&#x2F;etc&#x2F;login.defs：创建用户时参考的一些设置<br>&#x2F;etc&#x2F;skel:创建新用户时会从此目录拷贝文件到新用户的家目录中</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程管理</title>
    <link href="/2025/10/21/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2025/10/21/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程是一个在系统中运行的程序<br>进程是已启动的可执行程序的运行实例，进程有以下组成部分</p><ul><li>已分配内存的地址空间</li><li>安全属性，包括所有权凭据和特权</li><li>进程代码的一个或多个执行线程</li><li>进程状态</li></ul><p>程序：二进制文件，是静态的</p><p>&#x2F;bin&#x2F;date，&#x2F;usr&#x2F;sbin&#x2F;httpd，&#x2F;usr&#x2F;sbin&#x2F;sshd，&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;ngix</p><p>进程：是程序运行的过程，动态的，有生命周期及运行状态</p><h2 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h2><p>守护进程：在系统引导过程中启动的进程，跟终端无关的进程</p><p>前台进程：跟终端相关，通过终端启动的进程</p><h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p>父进程复制自己的地址空间(fork)创建一个新的(子)进程结构。每个新进程分配一个唯一的进程ID(PID)，满足跟踪安全性之需。PID和父进程ID(PPID)是子进程环境的元素，任何进程都可以创建子进程，所有进程都是第一个系统进程的后代。</p><h1 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h1><p>首先 systmed 是一个用户空间的程序，属于应用程序，不属于 Linux 内核范畴。Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit（这个是centos6中的初始化系统）固有的缺点，提高系统的启动速度。</p><p>Linux内核加载启动后，用户空间的第一个进程就是初始化进程，这个程序的物理文件约定位于&#x2F;sbin&#x2F;init，当然也可以通过传递内核参数来让内核启动指定的程序。这个进程的特点是进程号为1，代表第一个运行的用户空间进程。</p><p>RockyLinux上所有的进程都是systemd的后代，systemd的功能繁多，不仅用来管理服务，还可以管理挂载点，定义定时任务等。这些工作都是由编辑相应的配置单元文件完成的。</p><h1 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h1><p>systemctl 是 systemd 的控制命令，用于管理 systemd 服务。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>systemctl start name.service</td><td>启动服务</td></tr><tr><td>systemctl stop name.service</td><td>停止服务</td></tr><tr><td>systemctl restart name.service</td><td>重启服务（没启动的服务会启动）</td></tr><tr><td>systemctl try-restart name.service</td><td>只重启正在运行的服务</td></tr><tr><td>systemctl reload name.service</td><td>重载配置文件</td></tr><tr><td>systemctl status name.service systemctl is-active name.service</td><td>检查服务状态检查服务是否启动</td></tr><tr><td>systemctl list-units –type service –all</td><td>显示所有的服务状态</td></tr><tr><td>systemctl enable name.service</td><td>启用开机自启服务</td></tr><tr><td>systemctl disable name.service</td><td>停用自启服务</td></tr><tr><td>systemctl status name.service systemctl is-enabled name.service</td><td>检查服务状态查看服务是否自启</td></tr><tr><td>systemctl list-unit-files –type service</td><td>查看所有服务</td></tr><tr><td>systemctl list-dependencies –after</td><td>列出在指定服务之前启动的服务（依赖）</td></tr><tr><td>systemctl list-dependencies –before</td><td>列出在指定服务之后启动的服务（被依赖）</td></tr></tbody></table><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>ps命令用于显示当前进程的状态，类似于 windows 的任务管理器</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li>-a：列出所有的进程</li><li>-e：列出所有的进程，等同于-A</li><li>-f：显示不包含资源使用率的相关信息</li><li>‐H：以进程层级格式显示进程相关信息</li><li>-w：显示加宽可以显示较多的信息</li><li>-u：显示较详细的信息</li><li>-x：显示其他使用者的进程</li></ul><p>显示信息的格式说明</p><table><thead><tr><th>列名</th><th>说明</th></tr></thead><tbody><tr><td>USER</td><td>进程拥有者</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>%CPU</td><td>占用的 CPU 使用率</td></tr><tr><td>%MEM</td><td>占用的内存使用率</td></tr><tr><td>VSZ</td><td>占用的虚拟内存大小</td></tr><tr><td>RSS</td><td>占用的常驻内存大小</td></tr><tr><td>TTY</td><td>执行的终端编号</td></tr><tr><td>STAT</td><td>该进程的状态*</td></tr><tr><td>START</td><td>进程开始时间</td></tr><tr><td>TIME</td><td>CPU使用时间</td></tr><tr><td>COMMAND</td><td>所执行的命令</td></tr></tbody></table><p>*STAT表示的进程状态有如下几种：</p><ul><li>D: 无法中断的休眠状态 ，将一直等待事件的发生或等待某种系统资源</li><li>R: 正在执行中</li><li>S: 可中断状态</li><li>T: 暂停执行</li><li>Z: 不存在但暂时无法消除，也叫僵尸进程<br>– 每个进程在运行结束后都会处于僵死状态，等待父进程调用进而释放系统资源，处于该状态的进程已经运行结束，但是它的父进程还没有释放其系统资源</li><li>W: 没有足够的内存可分配</li><li>&lt;: 高优先序的进程</li><li>N: 低优先序的进程</li><li>+：前台进程</li><li>l：多线程进程</li><li>s：主进程(先导进程)</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps aux"></a>ps aux</h3><p>显示所有进程，包含用户名，进程ID，CPU使用率，内存使用率，虚拟内存大小，常驻内存大小，终端编号，进程状态，进程开始时间，CPU使用时间等</p><h3 id="ps-aux-1"><a href="#ps-aux-1" class="headerlink" title="ps -aux"></a>ps -aux</h3><p>显示所有进程，包含用户名，进程ID，CPU使用率，内存使用率，虚拟内存大小，常驻内存大小，终端编号，进程状态，进程开始时间，CPU使用时间等</p><p>这两个命令功能一样，但是有着不同的含义：</p><ul><li>ps aux 是一种 BSD 风格 的 ps 命令，它不需要破折号（-）作为选项的前缀。</li><li>ps -aux这里的 - 表示使用的是 UNIX 标准 或 POSIX 标准 的 ps 选项</li></ul><h3 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a>ps -ef</h3><p>显示所有进程的完整格式程序信息，包含进程拥有者，进程ID，父进程ID，终端编号，进程状态，进程开始时间，进程名</p><h3 id="ps-efH"><a href="#ps-efH" class="headerlink" title="ps -efH"></a>ps -efH</h3><p>显示所有进程的完整格式程序信息，查看进程以层级格式（类似于pstree命令）</p><h3 id="按照CPU使用率排序查看所有进程"><a href="#按照CPU使用率排序查看所有进程" class="headerlink" title="按照CPU使用率排序查看所有进程"></a>按照CPU使用率排序查看所有进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ps -aux --<span class="hljs-built_in">sort</span> %cpu     <span class="hljs-comment"># 递增</span><br>[root@localhost ~]# ps -aux --<span class="hljs-built_in">sort</span> -%cpu    <span class="hljs-comment"># 递减</span><br></code></pre></td></tr></table></figure><h3 id="按照实际内存使用排序查看所有进程"><a href="#按照实际内存使用排序查看所有进程" class="headerlink" title="按照实际内存使用排序查看所有进程"></a>按照实际内存使用排序查看所有进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ps -aux --<span class="hljs-built_in">sort</span> rss     <span class="hljs-comment"># 递增</span><br>[root@localhost ~]# ps -aux --<span class="hljs-built_in">sort</span> -rss    <span class="hljs-comment"># 递减</span><br></code></pre></td></tr></table></figure><h3 id="按照父子进程显示ssh服务的层级关系"><a href="#按照父子进程显示ssh服务的层级关系" class="headerlink" title="按照父子进程显示ssh服务的层级关系"></a>按照父子进程显示ssh服务的层级关系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ps -auxf |grep sshd<br><span class="hljs-comment"># ps -efH</span><br>root       6814  0.0  0.2 112756  4320 ?        Ss   09:06   0:00 /usr/sbin/sshd -D<br>root       7097  0.0  0.2 158760  5576 ?        Ss   09:06   0:00  \_ sshd: root@pts/0<br>root       7337  0.1  0.2 158760  5588 ?        Ss   10:21   0:00  \_ sshd: root@pts/1<br>root       7364  0.0  0.0 112724   988 pts/1    S+   10:24   0:00          \_ grep --color=auto sshd<br></code></pre></td></tr></table></figure><h3 id="自定义显示格式"><a href="#自定义显示格式" class="headerlink" title="自定义显示格式"></a>自定义显示格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ps -axo user,pid,ppid,%mem,%cpu,<span class="hljs-built_in">command</span> --<span class="hljs-built_in">sort</span> -%cpu<br></code></pre></td></tr></table></figure><h3 id="查看指定进程的PID，多种查看的方式"><a href="#查看指定进程的PID，多种查看的方式" class="headerlink" title="查看指定进程的PID，多种查看的方式"></a>查看指定进程的PID，多种查看的方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">cat</span> /run/sshd.pid <br>[root@localhost ~]# ps -aux |grep sshd<br>[root@localhost ~]# pgrep -l sshd<br>[root@localhost ~]# pidof sshd<br></code></pre></td></tr></table></figure><h3 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# yum install -y psmisc<br>[root@localhost ~]# pstree<br></code></pre></td></tr></table></figure><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>top命令用于显示当前正在运行的进程，更像windows 的任务管理器</p><p>第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。<br>第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵尸的进程数。<br>第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。<br>第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。（buffer和cache之间的区别，cache是提高cpu和内存之间的数据交换速度，buffer是io设备和存储设备之间的缓冲区）<br>第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p><p>在top命令中，load average(系统负载平均值)表示单位时间内处于可运行状态（Running）和不可中断睡眠状态（Uninterruptible Sleep）的进程总数，通常显示三个数值，分别对应过去1分钟、5分钟、15分钟的平均负载。<br>具体计算逻辑：</p><ul><li>1.计算范围：<br>– 包含正在CPU上运行的进程<br>– 包含等待CPU资源的进程（处于就绪队列）<br>– 包括处于不可中断睡眠状态的进程</li><li>2.计算方法：<br>系统通过一个“指数移动平均”算法计算，并非简单的算术平均。</li><li>3.数值含义：<br>– 若数值等于CPU核数，则表示CPU刚好能处理所有任务<br>– 若数值小于CPU核数，则表示CPU较空闲<br>– 若数值大于CPU核数，则表示任务堆积，系统可能繁忙（如CPU、I&#x2F;O资源不足）</li></ul><h2 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h2><ul><li>-d: 改变显示的更新速度，或是在交互式指令列( interactive command)按 s</li><li>-c: 切换显示模式，共有两种模式，一是只显示程序的名称，另一种是显示完整的路径与名称</li><li>-S: 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</li><li>-s: 安全模式，将交互式指令取消, 避免潜在的危机</li><li>-i: 不显示任何闲置 (idle) 或无用 (zombie) 的行程</li><li>-n: 更新的次数，完成后将会退出 top</li><li>-b: 显示模式，搭配 “n” 参数一起使用，可以配合重定向&gt;用来将 top 的结果输出到文件内</li><li>-z：彩色</li><li>-p : 指定进程ID</li><li>-u : 指定用户</li></ul><h2 id="交互模式快捷键"><a href="#交互模式快捷键" class="headerlink" title="交互模式快捷键"></a>交互模式快捷键</h2><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>空格</td><td>立即刷新</td></tr><tr><td>P根据CPU使用多少排序</td><td></td></tr><tr><td>T</td><td>根据时间、累计排序</td></tr><tr><td>q</td><td>退出top命令</td></tr><tr><td>m</td><td>切换显示内存信息</td></tr><tr><td>t</td><td>切换显示进程和CPU状态信息</td></tr><tr><td>c</td><td>切换显示命令名称和完整命令行</td></tr><tr><td>M</td><td>根据内存的大小排序</td></tr><tr><td>W</td><td>将当前设置写入 ~&#x2F;.toprc 文件中，这是top配置文件推荐方法</td></tr><tr><td>N</td><td>以PID的大小排序</td></tr><tr><td>z</td><td>彩色</td></tr></tbody></table><h1 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h1><p>kill 命令用于删除执行中的程序或工作<br>kill 可将指定的信号送至程序。预设的信号为 SIGTERM(15)，可将指定程序终止</p><p>使用 kill -l 命令列出所有可用信号，最常用的信号如下：</p><table><thead><tr><th>编号</th><th>信号名</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>重新加载配置</td></tr><tr><td>2</td><td>SIGINT</td><td>键盘中断ctrl c</td></tr><tr><td>3</td><td>SIGQUIT</td><td>键盘退出</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制终止</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止(正常结束)</td></tr><tr><td>18</td><td>SIGCONT</td><td>继续</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止</td></tr><tr><td>20</td><td>SIGTSTP</td><td>暂停ctrl z</td></tr></tbody></table><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#杀死所有的ping命令，在linux命令中，使用反引号`包含的命令会优先执行，并将执行的结果作为参数提供给命令。</span><br>[root@localhost ~]# <span class="hljs-built_in">kill</span> `pgrep ping`<br><span class="hljs-comment">#强制杀死进程</span><br>[root@localhost ~]# <span class="hljs-built_in">kill</span> -9 `pgrep ping`<br><span class="hljs-comment">#温柔地杀死进程</span><br>[root@localhost ~]# <span class="hljs-built_in">kill</span> -15 `pgrep ping`<br></code></pre></td></tr></table></figure><h1 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h1><p>pkill 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程<br>pkill [选项]  name</p><h2 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h2><ul><li>name： 进程名</li><li>-u：指定用户名</li><li>-t：指定终端</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#结束所有的sshd进程</span><br>[root@localhost ~]# pkill sshd<br><span class="hljs-comment">#结束用户user1的所有进程</span><br>[root@localhost ~]# pkill -u user1<br><span class="hljs-comment">#终止pts/2上所有进程</span><br>[root@localhost ~]# pkill -t pts/2<br><span class="hljs-comment">#终止pts/2上所有进程，并结束pts/2</span><br>[root@localhost ~]# pkill -9 -t pts/2<br><span class="hljs-comment">#查看远程登录用户，并踢出用户</span><br><span class="hljs-comment">#w是查看有哪些用户登录</span><br>[root@localhost ~]# w<br> 15:02:26 up  5:21,  2 <span class="hljs-built_in">users</span>,  load average: 0.05, 0.03, 0.05<br>USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT<br>root     tty1                      14:41   20:34   0.02s  0.02s -bash<br>root     pts/0    192.168.175.1    14:42    2.00s  0.05s  0.01s w<br>user1    pts/1   192.168.175.1     14:40   20:34   0.02s  0.02s -bash<br>[root@localhost ~]# pkill -u user1<br></code></pre></td></tr></table></figure><h1 id="进程优先级nice"><a href="#进程优先级nice" class="headerlink" title="进程优先级nice"></a>进程优先级nice</h1><h2 id="Linux进程调度及多任务"><a href="#Linux进程调度及多任务" class="headerlink" title="Linux进程调度及多任务"></a>Linux进程调度及多任务</h2><p>每个CPU(或CPU核心)在一个时间点上只能处理一个进程，通过时间片技术，Linux实际能够运行的进程 (和线程数)可以超出实际可用的CPU及核心数量。Linux内核进程调度程序将多个进程在CPU核心上快速切换，从而给用户多个进程在同时运行的假象。（并发）</p><h3 id="相对优先级"><a href="#相对优先级" class="headerlink" title="相对优先级"></a>相对优先级</h3><p>由于不是每个进程都与其他进程同样重要，可告知进程调度程序为不同的进程使用不同的调度策略。常规系统上运行的大多数进程所使用的的调度策略为SCHED_OTHER(也称为SCHED_NORMAL),但还有其他 一些调度策略用于不同的目的。SCHED_OTHER调度策略运行的进程的相对优先级称为进程的nice值， 可以有40种不同级别的nice值。<br>在Linux中，决定一个进程的优先级的因素有两个，一个是PR值，一个是NICE值，PR值是由系统内核动态调控。而NICE值由我们用户自己决定。不过，PR值跟NICE值之间也是有一定的关联的。</p><ul><li>NICE值的范围：-20到19，数值越小，优先级越高</li><li>PR值的范围：0-139（数值越小，优先级越高），0-99为实时进程优先级，100-139为普通进程优先级</li></ul><p>两者关系：<br>    普通进程的PR值&#x3D;100+NICE值</p><p>进程默认启动时nice为0，优先级为20</p><p>nice值越高表示优先级越低，例如19，该进程容易将CPU使用量让给其他进程<br>nice值越低表示优先级越高，例如-20，该进程更倾向于不让出CPU</p><h3 id="查看进程的nice级别"><a href="#查看进程的nice级别" class="headerlink" title="查看进程的nice级别"></a>查看进程的nice级别</h3><h4 id="ps-1"><a href="#ps-1" class="headerlink" title="ps"></a>ps</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ps -axo pid,<span class="hljs-built_in">command</span>,<span class="hljs-built_in">nice</span> --<span class="hljs-built_in">sort</span>=<span class="hljs-built_in">nice</span><br>[root@localhost ~]# ps -axo pid,<span class="hljs-built_in">command</span>,<span class="hljs-built_in">nice</span>,cls --<span class="hljs-built_in">sort</span>=-<span class="hljs-built_in">nice</span><br></code></pre></td></tr></table></figure><h4 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h4><h4 id="启用具有不同nice级别地进程"><a href="#启用具有不同nice级别地进程" class="headerlink" title="启用具有不同nice级别地进程"></a>启用具有不同nice级别地进程</h4><p>启动进程的时候为进程指定nice值<br>启动进程时，通常会继承父进程的nice级别，默认为0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">nice</span> -n -20 vim<br>[root@localhost ~]# ps -axo <span class="hljs-built_in">command</span>,pid,<span class="hljs-built_in">nice</span> |grep vim<br></code></pre></td></tr></table></figure><h2 id="PRI"><a href="#PRI" class="headerlink" title="PRI"></a>PRI</h2><p>在top命令中可以看到有PR这个数值，PR 和 nice 值，都会影响进程执行的优先级。PR 由 OS 内核动态调整，用户不能调整（PR 值越低，进程执行的优先级越高）。</p><p>nice值用户可以自己调整，在用户调整了nice值后系统会通过如下公式来调整新的PR值，从而确定这个进程在系统中的优先级</p><ul><li>PR(新) &#x3D; PR(旧) + nice<br>PR值是OS动态调整的，但是PR的最终值还是需要由OS分析决定的</li></ul><h3 id="更改现有进程地nice级别"><a href="#更改现有进程地nice级别" class="headerlink" title="更改现有进程地nice级别"></a>更改现有进程地nice级别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用shell更改nice级别</span><br>[root@localhost ~]# vim<br>[root@localhost ~]# ps -axo <span class="hljs-built_in">command</span>,pid,<span class="hljs-built_in">nice</span> |grep vim<br>vim                            1855   0<br>grep --color=auto vim          1888   0<br>[root@localhost ~]# renice -20 1855<br>1855 (process ID) old priority 0, new priority -20<br>[root@localhost ~]# ps -axo <span class="hljs-built_in">command</span>,pid,<span class="hljs-built_in">nice</span> |grep vim<br>vim                            1855 -20<br>grep --color=auto vim          1895   0<br></code></pre></td></tr></table></figure><h1 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h1><p>jobs 命令可以用来查看当前终端放入后台的任务</p><h2 id="将任务放入后台"><a href="#将任务放入后台" class="headerlink" title="将任务放入后台"></a>将任务放入后台</h2><p>Linux 命令放入后台的方法有两种：</p><ul><li>在命令后面加入空格 &amp;。使用这种方法放入后台的命令，在后台处于执行状态</li><li>命令执行过裎中按 Ctrl+Z 快捷键，命令在后台处于暂停状态</li></ul><p>将任务放入后台，然后查看任务</p><ul><li>“+”号代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作</li><li>“-“号代表倒数第二个放入后台的工作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# top &amp;<br>[root@localhost ~]# vi &amp;<br>[root@localhost ~]# ping baidu.com &gt; /dev/null &amp;<br><span class="hljs-comment"># 让ping运行，但是不显示结果</span><br><span class="hljs-comment">#/dev/null有点类似于windows的回收站</span><br>[root@localhost ~]# <span class="hljs-built_in">jobs</span><br>[1]   已停止               top<br>[2]-  已停止               vi<br>[3]+  运行中               ping baidu.com &gt; /dev/null &amp;<br></code></pre></td></tr></table></figure><h2 id="将任务恢复到前台"><a href="#将任务恢复到前台" class="headerlink" title="将任务恢复到前台"></a>将任务恢复到前台</h2><p>fg 命令用于把后台工作恢复到前台执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">fg</span> %工作号<br></code></pre></td></tr></table></figure><p>注意，在使用此命令时，％ 可以省略，但若将% 工作号全部省略，则此命令会将带有 + 号的工作恢复到前台。另外，使用此命令的过程中， % 可有可无。</p><p>将top恢复到前台</p><ul><li>命令虽然是对的，但是top这种需要交互的任务是无法后台的，所以也恢复不了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# top &amp;<br>[1] 20584<br>[root@localhost ~]# <span class="hljs-built_in">jobs</span><br>[1]+  已停止               top<br>[root@localhost ~]# <span class="hljs-built_in">fg</span> 1<br></code></pre></td></tr></table></figure><h2 id="后台任务恢复到后台运行"><a href="#后台任务恢复到后台运行" class="headerlink" title="后台任务恢复到后台运行"></a>后台任务恢复到后台运行</h2><p>前面讲过，使用Ctrl+z快捷键的方式，可以将前台工作放入后台，但是会处于暂停状态,可以使用bg命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">bg</span> %工作号<br></code></pre></td></tr></table></figure><p>这里的 % 同上，可以省略</p><p>将ping命令暂停到后台，然后恢复后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# ping baidu.com &gt; /dev/null<br>^Z    <span class="hljs-comment"># 这边按下了Ctrl+z</span><br>[1]+  已停止               ping baidu.com &gt; /dev/null<br>[root@localhost ~]# <span class="hljs-built_in">jobs</span><br>[1]+  已停止               ping baidu.com &gt; /dev/null<br>[root@localhost ~]# <span class="hljs-built_in">bg</span> %1<br>[1]+ ping baidu.com &gt; /dev/null &amp;<br>[root@localhost ~]# <span class="hljs-built_in">jobs</span><br>[1]+  运行中               ping baidu.com &gt; /dev/null &amp;<br></code></pre></td></tr></table></figure><h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>虽然可以将程序放在后台运行，但是一旦关闭远程连接那么程序就会中断，如果我们想要将程序一直保持在后台运行，那么我们可以有如下三个选择：</p><ul><li>把需要在后台执行的命令加入&#x2F;etc&#x2F;rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，如果有临时后台任务，就不能执行了</li><li>使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的</li><li>使用 nohup 命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> 命令 &amp;<br></code></pre></td></tr></table></figure><p>注意，这里的&amp;表示此命令会在终端后台工作；反之，如果没有&amp;，则表示此命令会在终端前台工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#让一个任务后台运行</span><br>[root@localhost ~]# <span class="hljs-built_in">nohup</span> ping baidu.com &amp;<br><span class="hljs-comment">#我们退出远程连接，然后重新登录回来，会看到ping baidu.com依旧在运行，查看~/nohup.out文件可以看到程序执行输出的内容</span><br>[root@localhost ~]# ps aux |grep ping<br>root       7157  0.0  0.0 149968  1988 ?        S    14:12   0:00 ping baidu.com<br>[root@localhost ~]# <span class="hljs-built_in">tail</span> -f nohup.out<br></code></pre></td></tr></table></figure><p>如果想要把nohup丢到后台的任务恢复，nohup本身不支持，可以用别的方法来实现</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件基本属性与文件查找</title>
    <link href="/2025/09/27/%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E4%BA%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/"/>
    <url>/2025/09/27/%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E4%BA%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h1><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>用于显示文件时间和 inode 内容</p><p>各种文件时间：</p><ul><li>Access time: 文件最后被访问的时间，也叫访问时间atime。</li><li>Modify time: 文件内容最后被修改的时间，也叫修改时间mtime。</li><li>Change time: 文件状态最后被改变的时间，也叫更改时间ctime。</li></ul><h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>Linux系统和Windows系统有很大的区别，Windows系统查看文件的后缀名就可以知道这个是什么类型的文件，比如：test.jpg这个是一个图片，如果你在windows上双击打开，就会使用支持查看图片的软件打开。<br>Linux系统就根本不看文件的后缀名，你认为这个是什么文件，你就使用什么工具打开这个文件，如果打开错误，就会报错。</p><h2 id="ls-l-ll"><a href="#ls-l-ll" class="headerlink" title="ls -l &#x2F; ll"></a>ls -l &#x2F; ll</h2><p>以长格式的形式输出</p><p>文件类型：</p><ul><li>d: 目录文件（蓝色）</li><li>l: 链接（淡蓝色）</li><li>-: 普通文件(文本文档，二进制文件，压缩文件，电影，图片···)</li><li>s: 套接字文件</li><li>b: 块设备文件(块设备)存储设备硬盘，U盘 &#x2F;dev&#x2F;sda,&#x2F;dev&#x2F;sda1</li><li>c: 字符设备文件(字符设备)打印机，终端 &#x2F;dev&#x2F;tty1,&#x2F;dev&#x2F;zero</li><li>p: 管道文件</li></ul><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>file是专门用来查看文件的类型的命令，有时候也可以使用</p><h2 id="stat-1"><a href="#stat-1" class="headerlink" title="stat"></a>stat</h2><p>stat命令可以查看文件的时间，类型，权限等信息</p><h1 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h1><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件</p><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>用于查找符合条件的文件，他会去保存文件和目录名称的数据库内，查找合乎范本样式条件的文件或目录</p><p>在使用locate之前，需要更新一下数据库，因为locate只会在数据库中查找文件所在的位置，所以locate查找速度极快，缺点就是数据库更新并不是实时的，更新数据库有两种方式：</p><ul><li>手动更新，输入updatedb</li><li>默认情况下，updatedb会每天自动执行一次</li></ul><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>-c：只输出找到的数量</li><li>-n：至多显示 n个输出</li><li>-i：忽略大小写</li><li>-r：使用基本正则表达式</li><li>–regex：使用扩展正则表达式</li><li>-d DBPATH：使用 DBPATH 指定的数据库，而不是默认数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db</li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>实时查找工具，通过遍历指定路径下的文件系统完成文件查找</p><p>find [选项] [路径] [查找条件 + 处理动作]</p><ul><li>查找路径：指定具体目录路径，默认是当前文件夹</li><li>查找条件：指定的查找标准（文件名&#x2F;大小&#x2F;类型&#x2F;权限等），默认是找出所有文件</li><li>处理动作：对符合条件的文件做什么操作，默认输出屏幕</li></ul><h3 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h3><ul><li>根据文件名查找 -name：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find /etc -name <span class="hljs-string">&quot;ens160.nmconnection&quot;</span><br>[root@localhost ~]# find /etc -iname <span class="hljs-string">&quot;ens160.nmconnection&quot;</span>    <span class="hljs-comment"># 忽略大小写</span><br>[root@localhost ~]# find /etc -iname <span class="hljs-string">&quot;ens*&quot;</span>     <span class="hljs-comment"># 匹配ens开头的文件</span><br></code></pre></td></tr></table></figure><ul><li>根据文件大小查找 -size：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find /etc -size +5M    <span class="hljs-comment"># 大于5M</span><br>[root@localhost ~]# find /etc -size 5M    <span class="hljs-comment"># 等于5M</span><br>[root@localhost ~]# find /etc -size -5M    <span class="hljs-comment"># 小于5M</span><br>[root@localhost ~]# find /etc -size +5M -<span class="hljs-built_in">ls</span>    <span class="hljs-comment"># 找到的处理动作-ls</span><br></code></pre></td></tr></table></figure><ul><li>指定查找的目录深度 -max(min)depth：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find / -maxdepth 3 -a -name <span class="hljs-string">&quot;ens160.nmconnection&quot;</span>    <span class="hljs-comment"># 最大查找深度</span><br><span class="hljs-comment"># -a是同时满足，-o是或</span><br>[root@localhost ~]# find / -mindepth 3 -a -name <span class="hljs-string">&quot;ens160.nmconnection&quot;</span>    <span class="hljs-comment"># 最小查找深度</span><br></code></pre></td></tr></table></figure><ul><li>根据时间查找 -m(a&#x2F;c)time：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find /etc -mtime +5    <span class="hljs-comment"># 修改时间超过5天</span><br>[root@localhost ~]# find /etc -mtime 5    <span class="hljs-comment"># 修改时间等于5天</span><br>[root@localhost ~]# find /etc -mtime -5    <span class="hljs-comment"># 修改时间5天以内</span><br></code></pre></td></tr></table></figure><ul><li>按照文件属主、属组找，文件的属主和属组查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find /home -user xwz    <span class="hljs-comment"># 属主是xwz的文件</span><br>[root@localhost ~]# find /home -group xwz<br>[root@localhost ~]# find /home -user xwz -group xwz<br>[root@localhost ~]# find /home -user xwz -a -group root<br>[root@localhost ~]# find /home -user xwz -o -group root<br>[root@localhost ~]# find /home -nouser        <span class="hljs-comment"># 没有属主的文件</span><br>[root@localhost ~]# find /home -nogroup        <span class="hljs-comment"># 没有属组的文件</span><br></code></pre></td></tr></table></figure><ul><li>根据文件类型查找 -type：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find /dev -<span class="hljs-built_in">type</span> d<br></code></pre></td></tr></table></figure><ul><li>按文件权限查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find / -perm 644 -<span class="hljs-built_in">ls</span><br>[root@localhost ~]# find / -perm -644 -<span class="hljs-built_in">ls</span>    <span class="hljs-comment"># 权限小于644的</span><br></code></pre></td></tr></table></figure><ul><li>按正则表达式查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# find /etc -regex <span class="hljs-string">&#x27;.*ens[0-9][0-9][0-9].*&#x27;</span><br><span class="hljs-comment"># .*  任意多个字符</span><br><span class="hljs-comment"># [0-9] 任意一个数字</span><br></code></pre></td></tr></table></figure><ul><li>条件组合<br>– -a：多个条件and并列<br>– -o：多个条件or并列<br>– -not：条件取反</li></ul><h3 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h3><ul><li>-print：默认的处理动作，显示至屏幕</li><li>-ls：显示文件详细信息</li><li>-delete：删除文件</li><li>-fls &#x2F;path&#x2F;to&#x2F;somefile：查找到的所有文件的长格式信息保存至指定文件中</li><li>-exec：选项允许您对找到的每个文件执行一个命令</li><li>{} ：用于引用查找到的文件名称自身</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用户权限管理</title>
    <link href="/2025/09/27/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/2025/09/27/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>为了更加方便的管理多个用户，就出现了用户组的概念，关于用户和用户组：</p><ul><li>系统上的每个进程(运行的程序)都是作为特定用户运行</li><li>每个文件是由一个特定的用户拥有</li><li>访问文件和目录受到用户的限制</li><li>与正在运行的进程相关联的用户确定该进程可访问的文件和目录</li></ul><h1 id="用户和用户组的查看"><a href="#用户和用户组的查看" class="headerlink" title="用户和用户组的查看"></a>用户和用户组的查看</h1><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>用于显示用户的id和所属群组的id</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>-g：显示用户所属群组的ID</li><li>-G：显示用户所属附加群组的ID</li><li>-n: 显示用户所属群组或附加群组的名称</li><li>-r: 显示用户真实ID，用户真实的uid</li><li>-u：显示用户有效ID</li></ul><h3 id="uid约定"><a href="#uid约定" class="headerlink" title="uid约定"></a>uid约定</h3><p>Linux操作系统会依据用户的uid数值来判定这个用户的角色，分别如下：</p><ul><li>0：超级管理员，也就是root，在linux系统中拥有所有权力</li><li>1~999：系统用户，系统用户往往是用来约束系统中的服务的</li><li>1000+：普通用户，可以用来登陆和使用Linux操作系统</li></ul><p>关于root用户：uid是0，拥有操作系统所有权力，该用户有权力覆盖文件系统上的普通权限，安装或删除软件并管理系统文件和目录，大多数设备只能由root控制。</p><p>查看运行进程的用户名：[root@localhost ~]# ps aux</p><h2 id="相关的文件"><a href="#相关的文件" class="headerlink" title="相关的文件"></a>相关的文件</h2><h3 id="passwd文件"><a href="#passwd文件" class="headerlink" title="passwd文件"></a>passwd文件</h3><p>用于保存用户的信息，一般第一行是root用户，下面都是其他用户<br>位置：&#x2F;etc&#x2F;passwd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">head</span> -n 1 /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br><span class="hljs-comment"># 这个格式为用户名:密码:uid:gid:描述:家目录:登陆后执行的命令</span><br><span class="hljs-comment">#家目录就是登录这个用户之后，所在文件的位置</span><br></code></pre></td></tr></table></figure><h3 id="shadow文件"><a href="#shadow文件" class="headerlink" title="shadow文件"></a>shadow文件</h3><p>格式中密码占位置太长了，所以使用x来替代，Linux系统会到shadow中查找x部分的的密码内容<br>位置：&#x2F;etc&#x2F;shawdow</p><h3 id="group文件"><a href="#group文件" class="headerlink" title="group文件"></a>group文件</h3><p>用户和组的对应关系会保存在group文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">head</span> -n 1 /etc/group<br>root:x:0:<br><span class="hljs-comment"># 这个格式是组名:口令:组标识号:组内用户列表</span><br></code></pre></td></tr></table></figure><h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><h2 id="添加用户组：groupadd"><a href="#添加用户组：groupadd" class="headerlink" title="添加用户组：groupadd"></a>添加用户组：groupadd</h2><p> groupadd 命令用于创建一个新的工作组，新工作组的信息将被添加到系统文件中</p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul><li>-g：指定新建工作组的 id；</li><li>-r：创建系统工作组，系统工作组的组ID小于500；</li><li>-K：覆盖配置文件&#x2F;etc&#x2F;login.defs</li><li>-o：允许添加组 ID 号不唯一的工作组。</li><li>-f：如果指定的组已经存在，此选项将失明了仅以成功状态退出。当与 -g 一起使用，并且指定的GID_MIN已经存在时，选择另一个唯一的GID（即-g关闭）。</li></ul><h2 id="修改用户组：groupmod"><a href="#修改用户组：groupmod" class="headerlink" title="修改用户组：groupmod"></a>修改用户组：groupmod</h2><p>groupmod命令用于更改群组识别码或名称</p><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul><li>-g：将组 ID 改为 GID</li><li>-n：改名为 NEW_GROUP</li><li>-o：允许使用重复的 GID</li></ul><h2 id="删除用户组：groupdel"><a href="#删除用户组：groupdel" class="headerlink" title="删除用户组：groupdel"></a>删除用户组：groupdel</h2><p>groupdel命令用于删除群组</p><p>需要从系统上删除群组时，可用groupdel(group delete)指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><h2 id="用户组成员管理：gpasswd"><a href="#用户组成员管理：gpasswd" class="headerlink" title="用户组成员管理：gpasswd"></a>用户组成员管理：gpasswd</h2><p>gpasswd 是 Linux 下工作组文件 &#x2F;etc&#x2F;group 和 &#x2F;etc&#x2F;gshadow 管理工具，用于将一个用户添加到组或者从组中删除</p><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><ul><li>-a：添加用户到组；</li><li>-d：从组删除用户；</li><li>-A：指定管理员，可以执行添加或者删除组员；</li><li>-M：替换组中的全部用户列表，不包含在内的用户将会从组中删除；</li><li>-R：限制用户登入组，只有组中的成员才可以用newgrp加入该组。</li></ul><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="添加用户：useradd"><a href="#添加用户：useradd" class="headerlink" title="添加用户：useradd"></a>添加用户：useradd</h2><p>useradd可以用来添加新的用户账号</p><h3 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h3><ul><li>-c comment：指定一段注释性描述。</li><li>-d 目录：指定用户主目录，如果此目录不存在，则同时使用- -m选项，可以创建主目录。</li><li>-m：创建用户的主目录</li><li>-g 用户组：指定用户所属的用户组，默认会创建一个和用户名同名的用户组。</li><li>-G 用户组：用户组 指定用户所属的附加组，一个用户可以属于多个附加组。</li><li>-s Shell文件：指定用户的登录Shell。</li><li>-u 用户号：指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul><h2 id="切换用户：ud"><a href="#切换用户：ud" class="headerlink" title="切换用户：ud"></a>切换用户：ud</h2><p>su命令用户Linux系统中的用户切换</p><h3 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h3><ul><li>-：以目标用户的环境变量启动新会话。这将模拟用户完全登录到新用户账户，包括其家目录、环境变量等。</li><li>-c 命令：执行指定的命令，并在执行完毕后返回原始用户。</li><li>-s shell：使用指定的 shell 替代目标用户的默认shell。</li></ul><h2 id="修改用户：usermod"><a href="#修改用户：usermod" class="headerlink" title="修改用户：usermod"></a>修改用户：usermod</h2><p>usermod命令用于修改用户帐号，可用来修改用户帐号的各项设定</p><h3 id="选项-6"><a href="#选项-6" class="headerlink" title="选项"></a>选项</h3><ul><li>-c&lt;备注&gt;：修改用户帐号的备注文字。</li><li>-a：追加，默认的修改是覆盖</li><li>-d登入目录&gt;：修改用户登入时的目录。</li><li>-e&lt;有效期限&gt;：修改帐号的有效期限。</li><li>-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号。</li><li>-g&lt;群组&gt;：修改用户所属的群组。</li><li>-G&lt;群组&gt;：修改用户所属的附加群组。</li><li>-l&lt;帐号名称&gt;：修改用户帐号名称。</li><li>-L：锁定用户密码，使密码无效。</li><li>-s：修改用户登入后所使用的shell。</li><li>-u：修改用户ID。</li><li>-U：解除密码锁定。</li></ul><h2 id="删除用户：userdel"><a href="#删除用户：userdel" class="headerlink" title="删除用户：userdel"></a>删除用户：userdel</h2><p>userdel命令用于删除用户帐号，可删除用户帐号与相关的文件。若不加参数，则仅删除用户帐号，而不删除相关文件。</p><ul><li>-r：删除用户登入目录以及目录中所有文件</li></ul><h1 id="passwd文件中的shell"><a href="#passwd文件中的shell" class="headerlink" title="passwd文件中的shell"></a>passwd文件中的shell</h1><p>查看&#x2F;etc&#x2F;passwd文件会发现在每行的最后是登录成功之后执行的命令，有两种是使用最为频繁的：</p><ul><li>&#x2F;bin&#x2F;bash：这个是Linux的命令行工具，我们正常登陆之后默认就是进入命令行</li><li>&#x2F;sbin&#x2F;nologin：如果写成nologin，那么用户将无法登录，有些用户是作为进程权限管理而存在的，不需要登录。如果提供登录的功能反而不安全，所以写成nologin</li></ul><h1 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="用户密码管理"></a>用户密码管理</h1><p>root用户可以直接设置普通用户密码，普通用户必须要提供原密码，才可以修改自己密码。</p><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>passwd命令用来更改使用者的密码</p><h3 id="选项-7"><a href="#选项-7" class="headerlink" title="选项"></a>选项</h3><ul><li>-k：保持身份验证令牌不过期</li><li>-d：删除已命名帐号的密码(只有根用户才能进行此操作)</li><li>-l：锁定指名帐户的密码(仅限 root 用户)</li><li>-u：解锁指名账户的密码(仅限 root 用户)</li><li>-x：密码的最长有效时限(只有根用户才能进行此操作)</li><li>-n：密码的最短有效时限(只有根用户才能进行此操作)</li><li>-w：在密码过期前多少天开始提醒用户(只有根用户才能进行此操作)</li><li>-i：当密码过期后经过多少天该帐号会被禁用(只有根用户才能进行此操作)</li><li>-S：报告已命名帐号的密码状态(只有根用户才能进行此操作)</li><li>–stdin：从标准输入读取令牌(只有根用户才能进行此操作)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# passwd test01<br>更改用户 test01 的密码 。<br>新的 密码：<br>重新输入新的 密码：<br>passwd：所有的身份验证令牌已经成功更新。<br><br>[root@localhost ~]# <span class="hljs-built_in">echo</span> 123456 | passwd --stdin test01<br>更改用户 test01 的密码 。<br>passwd：所有的身份验证令牌已经成功更新。<br></code></pre></td></tr></table></figure><h2 id="login-defs文件"><a href="#login-defs文件" class="headerlink" title="login.defs文件"></a>login.defs文件</h2><p>&#x2F;etc&#x2F;login.defs文件是用来创建用户时进行一定的限制，但是优先级低于&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow,如果有冲突的地方,系统会以&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow为准</p><h2 id="chage"><a href="#chage" class="headerlink" title="chage"></a>chage</h2><p>chage是用于更改用户密码过期信息</p><h3 id="选项-8"><a href="#选项-8" class="headerlink" title="选项"></a>选项</h3><ul><li>-d：设置密码的最后更改日期</li><li>-E 过期日期：设置账号的过期日期</li><li>-I INACITVE：设置密码过期后若未更改，多少天后用户账号被禁用。</li><li>-l：显示用户账号的密码过期信息。</li><li>-m 最小天数：设置两次改变密码之间相距的最小天数</li><li>-M 最大天数：设置将两次改变密码之间相距的最大天数</li><li>-W 警告天数：设置密码过期前的警告天数</li></ul><h1 id="sudoers"><a href="#sudoers" class="headerlink" title="sudoers"></a>sudoers</h1><p>Linux是多用户多任务的操作系统, 共享该系统的用户往往不只一个。出于安全性考虑, 有必要通过useradd创建一些非root用户, 只让它们拥有不完全的权限; 如有必要，再来提升权限执行。</p><p>sudo就是来解决这个需求的: 这些非root用户不需要知道root的密码，就可以提权到root，执行一些root才能执行的命令。</p><h2 id="sudo执行命令的过程"><a href="#sudo执行命令的过程" class="headerlink" title="sudo执行命令的过程"></a>sudo执行命令的过程</h2><p>1.当用户执行sudo时，系统会主动寻找&#x2F;etc&#x2F;sudoers文件，判断该用户是否有执行sudo的权限<br>2.确认用户具有可执行sudo的权限后，让用户输入用户自己的密码确认<br>3.若密码输入成功，则开始执行sudo后续的命令</p><h2 id="赋予用户sudo操作的权限"><a href="#赋予用户sudo操作的权限" class="headerlink" title="赋予用户sudo操作的权限"></a>赋予用户sudo操作的权限</h2><p>通过useradd添加的用户，并不具备sudo权限。在ubuntu&#x2F;centos&#x2F;RockyLinux等系统下, 需要将用户加入admin组或者wheel组或者sudo组。以root用户身份执行如下命令, 将用户加入wheel&#x2F;admin&#x2F;sudo组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">usermod -a -G wheel &lt;用户名&gt;<br><span class="hljs-comment"># 如果whell组不存在，则还需要先创建改组</span><br>groupadd wheel<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>sudo的权限控制可以在&#x2F;etc&#x2F;sudoers文件中查看到。一般来说，通过cat &#x2F;etc&#x2F;sudoers指令来查看该文件, 会看到如下几行代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# egrep -v <span class="hljs-string">&#x27;^[ ]*$|^#&#x27;</span> /etc/sudoers<br>=====省略=====<br>root    ALL=(ALL)     ALL<br>%wheel    ALL=(ALL)    ALL<br><br><span class="hljs-comment">#对/etc/sudoers文件进行编辑的代码公式可以概括为</span><br>授权用户/组 主机=[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...<br>字段1 字段2 =[(字段3)] [字段4] 字段5<br></code></pre></td></tr></table></figure><p>凡是[ ]中的内容, 都能省略; 命令和命令之间用,号分隔，字段3、字段4，是可以省略的。</p><ul><li>“字段1”不以%号开头的表示”将要授权的用户”，以%号开头的表示”将要授权的组”。</li><li>“字段2”表示允许登录的主机, ALL表示所有，;如果该字段不为ALL,表示授权用户只能在某些机器上登录本服务器来执行sudo命令</li><li>“字段3”如果省略, 相当于(root:root)，表示可以通过sudo提权到root，如果为(ALL)或者(ALL:ALL), 表示能够提权到(任意用户:任意用户组)。</li><li>“字段4”的可能取值是NOPASSWD:。请注意NOPASSWD后面带有冒号:。表示执行sudo时可以不需要输入密码。<br>– 比如:lucy ALL&#x3D;(ALL) NOPASSWD: &#x2F;bin&#x2F;useradd表示: 普通用户lucy可以在任何主机上, 通过sudo执行&#x2F;bin&#x2F;useradd命令, 并且不需要输入密码<br>– 比如:peter ALL&#x3D;(ALL) NOPASSWD: ALL,表示: 普通用户peter可以在任何主机上, 通过sudo执行任何命令, 并且不需要输入密码。</li><li>“字段5”是使用逗号分开一系列命令,这些命令就是授权给用户的操作; ALL表示允许所有操作。命令都是使用绝对路径, 这是为了避免目录下有同名命令被执行，从而造成安全隐患。<br>– 如果你将授权写成如下安全性欠妥的格式:lucy ALL&#x3D;(ALL) chown,chmod,useradd那么用户就有可能创建一个他自己的程序, 也命名为userad, 然后放在它的本地路径中, 如此一来他就能够使用root来执行这个”名为useradd的程序”。这是相当危险的!</li></ul><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>在实践中,去编辑&#x2F;etc&#x2F;sudoers文件，系统提示我没权限，这是因为&#x2F;etc&#x2F;sudoers的内容如此敏感，以至于该文件是只读的。所以，编辑该文件前，请确认清楚你知道自己正在做什么。</p><p>强烈建议通过visudo命令来修改该文件，通过visudo修改，如果配置出错，会有提示。</p><p>官方文档推荐的做法，不是直接修改&#x2F;etc&#x2F;sudoers文件，而是将修改写在&#x2F;etc&#x2F;sudoers.d&#x2F;目录下的文件中。如果使用这种方式修改sudoers，需要在&#x2F;etc&#x2F;sudoers文件的最后行，加上#includedir &#x2F;etc&#x2F;sudoers.d一行(默认已有)。需要注意，这个#includedir &#x2F;etc&#x2F;sudoers.d中的#并不是注释，请勿修改。</p><h2 id="sudo选项"><a href="#sudo选项" class="headerlink" title="sudo选项"></a>sudo选项</h2><ul><li>-u：以指定用户或 ID 运行命令(或编辑文件)</li><li>-l：显示出自己（执行 sudo 的使用者）的权限</li><li>-b：将要执行的指令放在后台执行</li><li>-i： 以目标用户身份运行一个登录 shell；可同时指定一条命令。相当于切换到root，不过只需要用户自己的密码即可。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件管理</title>
    <link href="/2025/09/26/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2025/09/26/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="表示文档的路径"><a href="#表示文档的路径" class="headerlink" title="表示文档的路径"></a>表示文档的路径</h2><ul><li>绝对路径：从根目录开始，如&#x2F;usr&#x2F;bin&#x2F;ls&#x2F;</li><li>相对路径：从当前目录开始，如bin&#x2F;ls</li></ul><h1 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h1><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>创建一个新的文件，如果文件已经存在，则修改文件时间，但不会覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">touch</span> test.txt<br></code></pre></td></tr></table></figure><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>创建一个目录，时刻要有绝对路径和相对路径的概念</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建root下面的a目录下的b目录下的c</span><br>[root@localhost ~]# <span class="hljs-built_in">mkdir</span> a/b/c -p<br><span class="hljs-comment">#不能写成/a/b/c，c，因为/a/b/c是绝对路径，这样就把a创建在了/根目录下面</span><br><span class="hljs-comment">#一定要加-p，因为如果要创建a/b/c，那么一定要先有a、b才能创建c</span><br></code></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>-p:创建多级目录，递归创建</li><li>-v:显示创建的目录</li><li>-m:设置目录权限</li></ul><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>拷贝文件</p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul><li>-r:递归持续复制</li><li>-f:强制覆盖，若目标文件已经存在且无法开启，则移除后再尝试一次</li><li>-v:显示拷贝的详细过程</li><li>-p:保留文件属性，常用于备份</li><li>-a:所有属性</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">mkdir</span> /home/dir&#123;1,2&#125;<br>[root@localhost ~]# <span class="hljs-built_in">touch</span> install.log<br><span class="hljs-comment"># 复制文件到目录下</span><br>[root@localhost ~]# <span class="hljs-built_in">cp</span> -v install.log /home/dir1<br><span class="hljs-comment"># 复制文件到目录下，并且重命名为abc.txt</span><br>[root@localhost ~]# <span class="hljs-built_in">cp</span> -v install.log /home/dir1/abc.txt<br><span class="hljs-comment"># 复制目录</span><br>[root@localhost ~]# <span class="hljs-built_in">cp</span> -rv /etc /home/dir1<br><span class="hljs-comment"># 将多个文件复制到同一个目录</span><br>[root@localhost ~]# <span class="hljs-built_in">cp</span> -rv /etc/passwd /etc/hostname /home/dir2<br><span class="hljs-comment"># 将多个文件复制到当前目录</span><br>[root@localhost ~]# <span class="hljs-built_in">cp</span> -rv /etc/passwd /etc/hostname .<br><span class="hljs-comment"># 备份配置文件,就是把install.log拷贝为install.log-old</span><br>[root@localhost ~]# <span class="hljs-built_in">cp</span> -rv install.log&#123;,-old&#125;<br></code></pre></td></tr></table></figure><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>移动文件或目录，或修改名称</p><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul><li>-f:强制覆盖，若目标文件已经存在且无法开启，则移除后再尝试一次</li><li>-v:显示移动的详细过程</li><li>-u:移动文件时，若目标文件已经存在且源文件比目标文件新，则覆盖目标文件</li><li>-i:移动文件时，若目标文件已经存在且源文件比目标文件新，则提示用户是否覆盖目标文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]# <span class="hljs-built_in">touch</span> file1<br><span class="hljs-comment"># 将file1移动到/home/dir2</span><br>[root@localhost ~]# <span class="hljs-built_in">mv</span> file1 /home/dir2<br>[root@localhost ~]# <span class="hljs-built_in">touch</span> file2<br><span class="hljs-comment"># 将file2移动到/home/dir2，并且改名file20</span><br>[root@localhost ~]# <span class="hljs-built_in">mv</span> file2 /home/dir2/file20<br><span class="hljs-comment"># 将file改名为file.txt</span><br>[root@localhost ~]# <span class="hljs-built_in">mv</span> file file.txt<br></code></pre></td></tr></table></figure><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件或目录</p><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><ul><li>-f:强制删除，若文件无法删除，则忽略</li><li>-i:删除文件时，提示用户是否删除</li><li>-r:递归删除</li><li>*：表示所有文件，一切</li></ul><h1 id="文本文件查看"><a href="#文本文件查看" class="headerlink" title="文本文件查看"></a>文本文件查看</h1><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>用于查看文本文件内容</p><h3 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h3><ul><li>-n:显示行号</li><li>-b:和 -n 相似，只不过对于空白行不编号</li><li>-s:去掉重复的空行</li><li>-A:显示非打印字符<br>cat倒过来tac也是查看，从最后一行开始显示</li></ul><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>可以随意浏览文件，支持翻页和和搜索<br>文件较大的时候，用less会比较方便</p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>查看文件的开头的部分，默认显示10行</p><h3 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h3><ul><li>n 数字:显示前n行</li></ul><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>显示文件最尾部的内容，默认显示10行</p><h3 id="选项-6"><a href="#选项-6" class="headerlink" title="选项"></a>选项</h3><ul><li>n 数字：显示最后n行，-n +m就是从第m行显示到最后</li><li>f ：持续显示文件内容，当文件内容增加时，会自动显示</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>针对文件内容进行过滤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在/etc/passwd的文件中找出有root的行</span><br>[root@xwz ~]# grep <span class="hljs-string">&#x27;root&#x27;</span> /etc/passwd<br><span class="hljs-comment"># 在/etc/passwd中找出root开头的行</span><br>[root@xwz ~]# grep <span class="hljs-string">&#x27;^root&#x27;</span> /etc/passwd<br><span class="hljs-comment"># 在/etc/passwd中找出bash结尾的行</span><br>[root@xwz ~]# grep <span class="hljs-string">&#x27;bash$&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure><h1 id="文本文件编辑"><a href="#文本文件编辑" class="headerlink" title="文本文件编辑"></a>文本文件编辑</h1><p>目前常见的命令行文本编辑器：</p><ul><li>nano：在debain系列的系统上会比较常见，但是其他的Linux发行版也都可以安装</li><li>vi：所有的 Unix Like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在。</li><li>vim：具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</li></ul><h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h2><h3 id="vim键盘图"><a href="#vim键盘图" class="headerlink" title="vim键盘图"></a>vim键盘图</h3><p><img src="D:\BlogFile\source_posts\photos\image.png" alt="vim键盘图">{width&#x3D;600px}</p><h3 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h3><ol><li><strong>命令模式</strong>：这是vim的默认模式，用于执行命令。</li></ol><ul><li>i切换到输入模式，以输入字符。</li><li>x删除当前光标所在处的字符。</li><li>:切换到末行模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。<br>命令模式只有一些最基本的命令，因此仍要依靠末行模式输入更多命令。</p><ol start="2"><li><strong>输入模式</strong>：</li></ol><ul><li>字符按键以及Shift组合，输入字符</li><li>ENTER，回车键，换行</li><li>BACK SPACE，退格键，删除光标前一个字符</li><li>DEL，删除键，删除光标后一个字符</li><li>方向键，在文本中移动光标</li><li>HOME&#x2F;END，移动光标到行首&#x2F;行尾</li><li>Page Up&#x2F;Page Down，上&#x2F;下翻页</li><li>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li><li>ESC，退出输入模式，切换到命令模式</li></ul><ol start="3"><li><strong>行末模式</strong>：</li></ol><ul><li>:q退出程序</li><li>:w保存文件</li><li>按ESC键可随时退出末行模式。</li></ul><h3 id="命令模式常用快捷键"><a href="#命令模式常用快捷键" class="headerlink" title="命令模式常用快捷键"></a>命令模式常用快捷键</h3><ul><li><p>0：移动光标到行首</p></li><li><p>$：移动光标到行末</p></li><li><p>G: 移动光标到文件末尾</p></li><li><p>nG: 移动光标到第n行，1G移动到第一行</p></li><li><p>gg: 移动光标到文件开头，也就是第一行</p></li><li><p>n+space: 移动光标向右n个字符</p></li><li><p>n+enter: 移动光标向下n行</p></li><li><p>&#x2F;word: 向下搜索word，并高亮显示 </p></li><li><p>?word: 向上搜索word，并高亮显示</p></li><li><p>n: 搜索结果中，向下移动到下一个匹配项，注意n是英文状态下的</p></li><li><p>N: 搜索结果中，向上移动到上一个匹配项</p></li><li><p>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字。在第n1与n2行之间寻找 word1 这个字符串，并将该字符串取代为word2 </p></li><li><p>:1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为word2！</p></li><li><p>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc：从第一行到最后一行寻找 word1 字符串，并将该字符串取代word2 ！且在取代前显示提示字符给用户确认是否需要取代！</p></li><li><p>dd：删除当前行</p></li><li><p>ndd：删除n行</p></li><li><p>yy：复制当前行</p></li><li><p>nyy：复制n行</p></li><li><p>p&#x2F;P：粘贴，p粘贴到光标所在下一行，P粘贴到光标所在上一行</p></li><li><p>u：撤销</p></li><li><p>nu：重复撤销n次</p></li><li><p>有哪些方法可以删除全文：<br>– dd dG<br>– G d1G<br>– G dgg<br>– :%d<br>– :1,$d</p></li><li><p>有哪些方法可以保存并退出：<br>– :wq<br>– :x<br>– ZZ</p></li><li><p>r ：进行替换</p></li><li><p>R：一直替换</p></li><li><p>Esc：结束替换</p></li><li><p>i：在光标处进行插入</p></li><li><p>I：在所在行第一个非空字符进行插入</p></li><li><p>a：在光标下的第一个字符进行插入</p></li><li><p>A：在所在行最后一个字符进行插入</p></li><li><p>o：在光标所在下一行进行插入</p></li><li><p>O：在光标所在上一行进行插入</p></li></ul><h3 id="行末模式常用快捷键"><a href="#行末模式常用快捷键" class="headerlink" title="行末模式常用快捷键"></a>行末模式常用快捷键</h3><ul><li>:w 保存文件，可以后面加文件名，保存为另一个文件，类似于另存为</li><li>:q 退出程序</li><li>:q! 退出程序，但未保存</li><li>:wq 退出程序，并保存文件</li><li>:n1,n2 w [filename]：截取n1到n2行，并保存为filename文件</li></ul><h3 id="vim环境变量修改"><a href="#vim环境变量修改" class="headerlink" title="vim环境变量修改"></a>vim环境变量修改</h3><ul><li>:set nu：显示行号</li><li>:set nonu：不显示行号</li><li>:set ai：智能缩进,回车后下一行的缩进和上一行一样</li><li>:set noai：取消智能缩进<br>说明：这里的配置只是针对当前shell，如果退出shell，则配置将失效。如果需要永久生效，则需要修改vimrc文件。vimrc是仅针对当前用户的，&#x2F;etc&#x2F;vimrc是针对所有用户的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行</title>
    <link href="/2025/09/25/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <url>/2025/09/25/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="初始shell"><a href="#初始shell" class="headerlink" title="初始shell"></a>初始shell</h1><p>用户直接输入命令，Linux是理解不了的，Shell就会在中间充当翻译官的角色，把用户的命令翻译给Linux内核，然后Linux内核会执行命令。</p><p>用户就可以使用Shell，对Linux系统进行大部分的管理。</p><p>使用Shell分为两种方式：<br>1.交互式命令行，输入一行回车后执行一行的命令，适合量少的工作。<br>2.Shell脚本，输入多行命令，然后保存为文件，然后执行文件，适合批量工作或重复性的工作。</p><h1 id="Bash-Shell提示符"><a href="#Bash-Shell提示符" class="headerlink" title="Bash Shell提示符"></a>Bash Shell提示符</h1><p>登录Linux系统后，默认进入交互式命令行模式，光标前面就会会看到提示符，提示符一般格式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]#<br>[用户名@主机名 目录名]权限标识<br></code></pre></td></tr></table></figure><p>用户名：当前登录的用户名<br>主机名：当前登录的计算机名称，修改主机名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostnametcl set-hostname 新主机名<br><span class="hljs-comment">#可能不会立即生效，Ctrl+D退出再登录新的主机名就会生效</span><br></code></pre></td></tr></table></figure><p>目录名：当前光标所在的目录，用户家目录表示成~<br>权限标识：超级管理员权限就表示成#，普通用户权限就表示成$</p><h1 id="常见的命令"><a href="#常见的命令" class="headerlink" title="常见的命令"></a>常见的命令</h1><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>用于显示当前文件下所含的内容（文件即子目录）<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment"># 查看当前目录下的文件</span><br>[root@localhost ~]# <span class="hljs-built_in">ls</span><br><br> <span class="hljs-comment"># 查看当前目录下的所有文件，包括隐藏文件即以.开头的文件</span><br>[root@localhost ~]# <span class="hljs-built_in">ls</span> -a<br><br> <span class="hljs-comment"># 查看当前目录下的文件详情，包括隐藏文件</span><br> [root@localhost ~]# <span class="hljs-built_in">ls</span> -hal<br><br> <span class="hljs-comment"># 查看/usr/sbin目录下的文件，并显示处目录文件程序的区别</span><br> <span class="hljs-comment"># 普通的文件只有文件名，可执行文件后面带*，文件夹后面带/</span><br> [root@localhost ~]# <span class="hljs-built_in">ls</span> -F /usr/sbin/<br></code></pre></td></tr></table></figure></p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p> 选项的循序随便</p><ul><li>-a:显示所有的隐藏文件</li><li>-l:显示文件的详细信息</li><li>-h:显示文件大小为可读性即将显示出来的文件大小以合适的单位显示出来</li><li>-F:显示文件类型，在文件名称后面加上文件类型标识符，例如可执行文档加*、目录加&#x2F;、链接加@</li><li>-R:递归显示所有子目录下的文件，把目录下面的文件也列出来</li><li>-t:按照文件创建的时间排序</li><li>-r：将结果进行逆序排序</li></ul><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p> 当前用户所在的目录</p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p> 用于当前切换工作目录<br> Linux里面的所有目录都是以&#x2F;开头的<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到/usr/bin目录</span><br>[root@localhost ~]# <span class="hljs-built_in">cd</span> /usr/bin<br><br><span class="hljs-comment"># 切换到上一级目录</span><br>[root@localhost bin]# <span class="hljs-built_in">cd</span> ..<br><br><span class="hljs-comment"># 切换到家目录</span><br>[root@localhost bin]# <span class="hljs-built_in">cd</span> ~<br><br><span class="hljs-comment"># 返回上一次所在目录</span><br>[root@localhost ~]# <span class="hljs-built_in">cd</span> -<br></code></pre></td></tr></table></figure></p><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p> 清屏，快捷键Ctrl+L也可以</p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p> 用于字符串的输出<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment"># 显示出hello world</span><br> [root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-comment"># 用两行显示出hello world</span><br> [root@localhost ~]# <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;hello\nworld&quot;</span><br><span class="hljs-comment"># 输出hello world的时候让系统发出警报音</span><br> [root@localhost ~]# <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;hello\aworld&quot;</span><br></code></pre></td></tr></table></figure></p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul><li>-n:换行符，光标留在行尾</li><li>-e:转义字符，允许对下列出的加反斜线的转移字符进行解释<br>– \a报警符<br>– \b退格符<br>– \f换页符<br>– \n换行符<br>– \r回车符<br>– \t水平制表符<br>– \v垂直制表符</li></ul><h1 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h1><h2 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h2><p>关闭系统</p><h2 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h2><p>重启系统</p><h2 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h2><p>显示当前用户名</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>Ctrl+C:终止当前正在执行的命令</li><li>Ctrl+D:退出当前用户，等价于exit</li><li>Ctrl+L:清屏</li><li>Ctrl+A:将光标移动到行首</li><li>Ctrl+E:将光标移动到行尾</li><li>Ctrl+K:删除从光标到行尾的所有字符</li><li>Ctrl+U:删除从行首到光标之间的所有字符</li><li>Ctrl+R:搜索历史命令，利用关键词</li></ul><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>查看历史输入的命令</p><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><ul><li>-c:清除当前shell中所有历史命令</li><li>-r:从历史文件中读取命令</li><li>-w:将当前shell中的所有历史命令保存到历史文件中</li></ul><p>使用！执行历史命令</p><ul><li>!n:执行历史命令第n条</li><li>!string:从最近的命令中执行以string开头的命令</li><li>!-n:执行历史命令倒数第n条</li><li>！！:执行上一条命令</li></ul><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>查看命令的帮助信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看echo的帮助信息</span><br>[root@localhost ~]# <span class="hljs-built_in">help</span> <span class="hljs-built_in">echo</span><br></code></pre></td></tr></table></figure><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>查看命令的帮助手册<br>-快捷键</p><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>&#x2F;</td><td>从上至下搜索某个关键词，如“&#x2F;linux”</td></tr><tr><td>?</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr></tbody></table><p>-手册的结构</p><table><thead><tr><th>结构名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NAME</td><td>命令的名称</td></tr><tr><td>SYNOPSIS</td><td>参数的大致使用方法</td></tr><tr><td>DESCRIPTION</td><td>介绍说明</td></tr><tr><td>EXAMPLES</td><td>演示（附带简单说明）</td></tr><tr><td>OVERVIEW</td><td>概述</td></tr><tr><td>DEFAULTS</td><td>默认的功能</td></tr><tr><td>OPTIONS</td><td>具体的可用选项（带介绍）</td></tr><tr><td>ENVIRONMENT</td><td>环境变量</td></tr><tr><td>FILES</td><td>用到的文件</td></tr><tr><td>SEE ALSO</td><td>相关的资料</td></tr><tr><td>HISTORY</td><td>维护历史与联系方式</td></tr></tbody></table><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>查看系统当前的别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改别名</span><br>[root@localhost ~]# <span class="hljs-built_in">alias</span> wl=<span class="hljs-string">&#x27;ip address&#x27;</span>（只在当前的环境生效，重登后就没用了）<br>[root@localhost ~]# wl<br><br><span class="hljs-comment"># 永久修改别名</span><br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias wl=&#x27;ip address&#x27;&quot;</span> &gt;&gt; /etc/bashrc<br></code></pre></td></tr></table></figure><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统当前的环境变量</span><br>[root@localhost ~]# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 修改环境变量 临时生效</span><br>[root@localhost ~]# <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux基础部分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>两数之和 - 从双重循环到哈希字典的优化</title>
    <link href="/2025/09/21/2025.9.21/"/>
    <url>/2025/09/21/2025.9.21/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值 <code>target</code> 的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方法一：双重循环（暴力枚举）"><a href="#方法一：双重循环（暴力枚举）" class="headerlink" title="方法一：双重循环（暴力枚举）"></a>方法一：双重循环（暴力枚举）</h3><p><strong>思路</strong>：遍历每个元素 <code>x</code>，并查找是否存在一个值与 <code>target - x</code> 相等的目标元素。</p><p><strong>时间复杂度</strong>：O(n²) - 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素。<br><strong>空间复杂度</strong>：O(1) - 只使用了常数级别的额外空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i, j]<br></code></pre></td></tr></table></figure><h3 id="方法二：哈希表-字典（优化解法）"><a href="#方法二：哈希表-字典（优化解法）" class="headerlink" title="方法二：哈希表&#x2F;字典（优化解法）"></a>方法二：哈希表&#x2F;字典（优化解法）</h3><p><strong>思路</strong>：使用字典（哈希表）来存储每个元素的值及其索引。在遍历数组时，我们检查当前元素所需的补数（target - num）是否已经存在于字典中。如果存在，立即返回结果；如果不存在，则将当前元素的值和索引存入字典，继续遍历。</p><p><strong>时间复杂度</strong>：O(n) - 我们只遍历了包含有 n 个元素的列表一次。在字典中查找补数的时间复杂度为 O(1)。</p><p><strong>空间复杂度</strong>：O(n) - 所需的额外空间取决于字典中存储的元素数量，最多需要存储 n 个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums, target</span>):<br>        hashmap = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            complement = target - num<br>            <span class="hljs-comment"># 检查补数是否已在哈希表中</span><br>            <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> hashmap:<br>                <span class="hljs-keyword">return</span> [hashmap[complement], i]<br>            <span class="hljs-comment"># 将当前数字存入哈希表（注意：必须在检查之后存入！）num当索引，i当值</span><br>            hashmap[num] = i<br></code></pre></td></tr></table></figure><p><strong>hashmap中根据 Key 找 Value</strong>：my_dict[‘name’]&#x2F;my_dict.get(‘name’)<br><strong>hashmap中根据 Value 找 Key</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历查找（找到第一个匹配的）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_key_by_value</span>(<span class="hljs-params">dictionary, target_value</span>):<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> dictionary.items():<br>        <span class="hljs-keyword">if</span> value == target_value:<br>            <span class="hljs-keyword">return</span> key<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 如果没找到</span><br><br><span class="hljs-comment">#列表推导式（找到所有匹配的key）</span><br>keys = [key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items() <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#字典推导式（创建一个新字典，将value变为key，将key变为value）</span><br><span class="hljs-comment">#创建反向字典（注意：value必须是唯一的）</span><br>reverse_dict = &#123;value: key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items()&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
